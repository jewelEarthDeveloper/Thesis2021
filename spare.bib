





@Inbook{Mens2008,
author="Mens, Tom",
title="Introduction and Roadmap: History and Challenges of Software Evolution",
bookTitle="Software Evolution",
year="2008",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="1--11",
abstract="The ability to evolve software rapidly and reliably is a major challenge for software engineering. In this introductory chapter we start with a historic overview of the research domain of software evolution. Next, we briefly introduce the important research themes in software evolution, and identify research challenges for the years to come. Finally, we provide a roadmap of the topics treated in this book, and explain how the various chapters are related.",
isbn="978-3-540-76440-3",
doi="10.1007/978-3-540-76440-3_1",
url="https://doi.org/10.1007/978-3-540-76440-3_1"
}



@incollection{mens2008introduction,
  title={Introduction and roadmap: History and challenges of software evolution},
  author={Mens, Tom},
  booktitle={Software evolution},
  pages={1--11},
  year={2008},
  publisher={Springer}
}

@book{mens_demeyer_2008, place={New York}, title={Software evolution}, publisher={Springer}, author={Mens, Tom and Demeyer, Serge}, year={2008}}

@article{Herraiz:2013:ELS:2543581.2543595,
 author = {Herraiz, Israel and Rodriguez, Daniel and Robles, Gregorio and Gonzalez-Barahona, Jesus M.},
 title = {The Evolution of the Laws of Software Evolution: A Discussion Based on a Systematic Literature Review},
 journal = {ACM Comput. Surv.},
 issue_date = {November 2013},
 volume = {46},
 number = {2},
 month = dec,
 year = {2013},
 issn = {0360-0300},
 pages = {28:1--28:28},
 articleno = {28},
 numpages = {28},
 url = {http://doi.acm.org/10.1145/2543581.2543595},
 doi = {10.1145/2543581.2543595},
 acmid = {2543595},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Laws of software evolution, software evolution},
}
@inproceedings{Klint:2009:RDS:1637859.1638018,
 author = {Klint, Paul and Storm, Tijs van der and Vinju, Jurgen},
 title = {RASCAL: A Domain Specific Language for Source Code Analysis and Manipulation},
 booktitle = {Proceedings of the 2009 Ninth IEEE International Working Conference on Source Code Analysis and Manipulation},
 series = {SCAM '09},
 year = {2009},
 isbn = {978-0-7695-3793-1},
 pages = {168--177},
 numpages = {10},
 url = {http://dx.doi.org/10.1109/SCAM.2009.28},
 doi = {10.1109/SCAM.2009.28},
 acmid = {1638018},
 publisher = {IEEE Computer Society},
 address = {Washington, DC, USA},
 keywords = {source code analysis, source code manipulation, meta-programming, transformation},
} 


@ARTICLE{268921, 
author={N. Fenton}, 
journal={IEEE Transactions on Software Engineering}, 
title={Software measurement: a necessary scientific basis}, 
year={1994}, 
volume={20}, 
number={3}, 
pages={199-206}, 
keywords={measurement theory;programming theory;software metrics;complexity attributes;measurement theory;metrics validation;scientific basis;software complexity measures;software measurement;software metrics work;Blood pressure;Cost function;Counting circuits;Gain measurement;Humans;Software measurement;Software metrics;Software reliability;Software testing}, 
doi={10.1109/32.268921}, 
ISSN={0098-5589}, 
month={Mar},}

@inproceedings{4335232
,	author	= {Heitlager, I and Kuipers, T and Visser, J}
,	booktitle	= {Quality of Information and Communications Technology, 2007. QUATIC 2007. 6th International Conference on the}
,	doi	= {10.1109/QUATIC.2007.8}
,	month	= {sep}
,	pages	= {30--39}
,	title	= {A Practical Model for Measuring Maintainability}
,	year	= {2007}
}

@INPROCEEDINGS{6976088, 
author={D. Landman and A. Serebrenik and J. Vinju}, 
booktitle={2014 IEEE International Conference on Software Maintenance and Evolution}, 
title={Empirical Analysis of the Relationship between CC and SLOC in a Large Corpus of Java Methods}, 
year={2014}, 
volume={}, 
number={}, 
pages={221-230}, 
keywords={Java;public domain software;software metrics;software quality;source code (software);CC;Java methods;SLOC;cyclomatic complexity;internal source code quality measurement;open-source Java projects;software development;source code quality metric;source lines-of-code;strong linear correlation;Complexity theory;Correlation;Java;Measurement;Software;Transforms;cylcomatic complexity;emperical research;software quality}, 
doi={10.1109/ICSME.2014.44}, 
ISSN={1063-6773}, 
month={Sept},}


@article{van2002goal,
  title={Goal question metric (gqm) approach},
  author={Van Solingen, Rini and Basili, Vic and Caldiera, Gianluigi and Rombach, H Dieter},
  journal={Encyclopedia of software engineering},
  year={2002},
  publisher={Wiley Online Library}
}

@Inbook{koschke2008identifying,
title={Identifying and Removing Software Clones.},
bookTitle="Software Evolution",
year="2008",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
author={Koschke, Rainer},
pages={15–36},
isbn="978-3-540-76440-3"
}

@INPROCEEDINGS{4023973, 
author={C. Kapser and M. W. Godfrey}, 
booktitle={2006 13th Working Conference on Reverse Engineering}, 
title={"Cloning Considered Harmful" Considered Harmful}, 
year={2006}, 
volume={}, 
number={}, 
pages={19-28}, 
abstract={Current literature on the topic of duplicated (cloned) code in software systems often considers duplication harmful to the system quality and the reasons commonly cited for duplicating code often have a negative connotation. While these positions are sometimes correct, during our case studies we have found that this is not universally true, and we have found several situations where code duplication seems to be a reasonable or even beneficial design option. For example, a method of introducing experimental changes to core subsystems is to duplicate the subsystem and introduce changes there in a kind of sandbox testbed. As features mature and become stable within the experimental subsystem, they can then be introduced gradually into the stable code base. In this way risk of introducing instabilities in the stable version is minimized. This paper describes several patterns of cloning that we have encountered in our case studies and discusses the advantages and disadvantages associated with using them}, 
keywords={software maintenance;code cloning;code duplicating;software system;Cloning;Computer science;Costs;Libraries;Reverse engineering;Software architecture;Software systems;Stability;Testing}, 
doi={10.1109/WCRE.2006.1}, 
ISSN={1095-1350}, 
month={Oct},}



@Inbook{Herrmanns,
author="Herrmannsd{\"o}rfer, Markus
and Wachsmuth, Guido",
editor="Mens, Tom
and Serebrenik, Alexander
and Cleve, Anthony",
title="Coupled Evolution of Software Metamodels and Models",
bookTitle="Evolving Software Systems",
year="2014",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="33--63",
abstract="In model--driven software engineering, software models are the primary engineering artifacts which are built using dedicated modeling languages. In response, modeling languages are receiving increased adoption to improve software engineering in industry, and thus their maintenance is gaining importance. Like software, modeling languages and thus their metamodels are subject to evolution due to changing requirements. When a metamodel evolves, models may no longer conform to it. To be able to use these models with the new modeling language, they need to be migrated. Metamodel evolution and the corresponding model migration are coupled. In this chapter, we introduce the problem, classify it, and discuss how it can be addressed. To get a feeling about the extent of the problem in practice, we give an overview of the empirical results that are available in the literature. We then present different approaches to the problem and classify them according to a number of features. Finally, we give an overview of the available tools and compare them to each other, before we conclude the chapter with directions for future work.",
isbn="978-3-642-45398-4",
doi="10.1007/978-3-642-45398-4_2",
url="https://doi.org/10.1007/978-3-642-45398-4_2"
}
@inproceedings{alanen2003difference,
  title={Difference and union of models},
  author={Alanen, Marcus and Porres, Ivan},
  booktitle={UML},
  volume={2863},
  pages={2--17},
  year={2003},
  organization={Springer}
}
@article{roy2009comparison,
  title={Comparison and evaluation of code clone detection techniques and tools: A qualitative approach},
  author={Roy, Chanchal K and Cordy, James R and Koschke, Rainer},
  journal={Science of computer programming},
  volume={74},
  number={7},
  pages={470--495},
  year={2009},
  publisher={Elsevier}
}

@article{sudhamani2015structural,
  title={Structural similarity detection using structure of control statements},
  author={Sudhamani, M and Rangarajan, Lalitha},
  journal={Procedia Computer Science},
  volume={46},
  pages={892--899},
  year={2015},
  publisher={Elsevier}
}

@inproceedings{Klint:2010:IDT:1868281.1868291,
 author = {Klint, Paul and van der Storm, Tijs and Vinju, Jurgen},
 title = {On the Impact of DSL Tools on the Maintainability of Language Implementations},
 booktitle = {Proceedings of the Tenth Workshop on Language Descriptions, Tools and Applications},
 series = {LDTA '10},
 year = {2010},
 isbn = {978-1-4503-0063-6},
 location = {Paphos, Cyprus},
 pages = {10:1--10:9},
 articleno = {10},
 numpages = {9},
 url = {http://doi.acm.org/10.1145/1868281.1868291},
 doi = {10.1145/1868281.1868291},
 acmid = {1868291},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {domain specific languages, language engineering, maintainability, tools},
} 


@InProceedings{	  lemma2013ckl,
  title		= {Co-Evolution as the Key for Live Programming},
  pages		= {9 - 10},
  lpssynthesisdomains={generalApplicationDevelopment},
  isbn		= {978-1-4673-6265-8},
  liveprogstudyorigins={#('ieee' 'live programming'), #('dblp'
		  'live+programming'), #('acm' 'live programming')},
  address	= {Piscataway, NJ, USA},
  publisher	= {IEEE Press},
  url		= {http://dl.acm.org/citation.cfm?id=2662726.2662729},
  location	= {San Francisco, California},
  year		= {2013},
  lpssynthesismethodofinquiry={systemDesign, designPrinciples},
  doi		= {10.1109/LIVE.2013.6617340},
  lpssynthesisintendedeffect={system},
  series	= {LIVE '13},
  file		= {live-systems-literature/LemmaLanza_2013_CoEvolutionAsTheKeyForLiveProgramming.pdf},
  lpssynthesismotivation={comprehension},
  abstract	= {The promise of live programming is to shorten or even
		  break the infamous edit-compile-run cycle, providing live
		  feedback on a program's envisioned behavior while it is
		  being written. Several live programming languages and
		  environments exist, from venerable examples (Smalltalk,
		  LISP) to more recent efforts like Ruby. In most cases
		  either the IDE comes as an afterthought, after the language
		  is designed, or novel languages are made to fit into
		  existing IDEs. We pursue a middle ground by co-evolving
		  both a language and its IDE: we are developing a novel live
		  programming language, called Moon, from scratch, and are
		  concurrently building its IDE. We illustrate our efforts so
		  far and discuss our overall vision.},
  author	= {Lemma, Remo and Lanza, Michele},
  booktitle	= {1st International Workshop on Live Programming (LIVE
		  2013)}
}


@InProceedings{	  burckhardt2013iac,
  author	= {Burckhardt, Sebastian and Fähndrich, Manuel and Halleux,
		  Peli and McDirmid, Sean and Moskal, Michal and Tillmann,
		  Nikolai and Kato, Jun},
  title		= {It's Alive! Continuous Feedback in UI Programming},
  booktitle	= {Proceedings of the Conference on Programming Language
		  Design and Implementation (PLDI) 2013},
  year		= {2013},
  volume	= {48},
  number	= {6},
  series	= {PLDI '13},
  pages		= {95 - 104},
  address	= {New York, NY, USA},
  publisher	= {ACM},
  abstract	= {Live programming allows programmers to edit the code of a
		  running program and immediately see the effect of the code
		  changes. This tightening of the traditional
		  edit-compile-run cycle reduces the cognitive gap between
		  program code and execution, improving the learning
		  experience of beginning programmers while boosting the
		  productivity of seasoned ones. Unfortunately, live
		  programming is difficult to realize in practice as
		  imperative languages lack well-defined abstraction
		  boundaries that make live programming responsive or its
		  feedback comprehensible. This paper enables live
		  programming for user interface programming by cleanly
		  separating the rendering and non-rendering aspects of a UI
		  program, allowing the display to be refreshed on a code
		  change without restarting the program. A type and effect
		  system formalizes this separation and provides an
		  evaluation model that incorporates the code update step. By
		  putting live programming on a more formal footing, we hope
		  to enable critical and technical discussion of live
		  programming systems.},
  doi		= {10.1145/2491956.2462170},
  file		= {live-systems-literature/BurckhardtFahndrichDeHalleuxMcDirmidMoskalTillmannKato_2013_ItsAliveContinuousFeedbackInUiProgramming.pdf},
  isbn		= {978-1-4503-2014-6},
  issn		= {0362-1340},
  issue_date	= {June 2013},
  liveprogstudyorigins={#(#hull 'live coding'), #(#hull 'live+programming'),
		  #('acm' 'immediate AND feedback AND programming'), #(#hull
		  'immediate AND feedback AND programming'), #('acm' 'live
		  programming'), #(#hull 'live programming')},
  location	= {Seattle, Washington, USA},
  lpssynthesisdomains={userInterfaceDevelopment},
  lpssynthesisintendedeffect={creatingAProgram},
  lpssynthesismethodofinquiry={toolDesign, formalMethods,
		  programmingLanguageDesign},
  lpssynthesismotivation={productivity},
  url		= {http://doi.acm.org/10.1145/2491956.2462170}
}


@Article{	  hundhausen2007aes,
  author	= {Hundhausen, Christopher and Brown, Jonathan},
  title		= {An Experimental Study of the Impact of Visual Semantic
		  Feedback on Novice Programming},
  journal	= {Journal of Visual Languages \& Computing},
  year		= {2007},
  volume	= {18},
  number	= {6},
  pages		= {537 - 559},
  issn		= {1045-926X},
  abstract	= {Prior empirical studies of programming have shown that
		  novice programmers tend to program by exploration, relying
		  on frequent compilation and execution of their code in
		  order to make progress. One way visual and end-user
		  programming environments have attempted to facilitate this
		  exploratory programming process is through their support of
		  ''live'' editing models, in which immediate visual feedback
		  on a program's execution is provided automatically at edit
		  time. Notice that the notion of ''liveness'' actually
		  encompasses two distinct dimensions: (a) the amount of time
		  a programmer must wait between editing a program and
		  receiving visual feedback (feedback delay); and (b) whether
		  such feedback is provided automatically, or whether the
		  programmer must explicitly request it (feedback
		  self-selection). While a few prior empirical studies of
		  ''live'' editing do exist, none has specifically evaluated
		  the impact of these dimensions of ''live'' editing within
		  the context of the imperative programming paradigm commonly
		  taught in first-semester computer science courses. As a
		  preliminary step toward that end, we conducted an
		  experimental study that investigated the impact of feedback
		  self-selection on novice imperative programming. Our
		  within-subjects design compared the impact of three
		  different levels of feedback self-selection on syntactic
		  and semantic correctness: (a) no visual feedback at all
		  (the No Feedback treatment); (b) visual feedback, in the
		  form of a visualization of the program's execution state,
		  provided on request when a ''run'' button is hit (the
		  Self-Select treatment); and (c) visual feedback, in the
		  form of a visualization of the program's execution state,
		  updated on every keystroke (the Automatic treatment).
		  Participants in the Automatic and Self-Select treatments
		  produced programs that had significantly fewer syntactic
		  and semantic errors than those of the No Feedback
		  treatment; however, no significant differences were found
		  between the Automatic and Self-Select treatments. These
		  results suggest that, at least in the case of novice
		  imperative programming environments, the benefits of
		  delivering a continuously updated visual representation of
		  a program's execution may fail to justify the substantial
		  costs of implementing such feedback. We recommend that
		  programming environment designers instead direct their
		  efforts toward carefully considering when programmers will
		  be ready to take advantage of the feedback that is coming
		  toward them, along with what content will be of most
		  benefit to them.},
  address	= {Orlando, FL, USA},
  doi		= {10.1016/j.jvlc.2006.09.001},
  file		= {live-systems-literature/HundhausenBrown_2007_AnExperimentalStudyOfTheImpactOfVisualSemanticFeedbackOnNoviceProgramming.pdf},
  issue_date	= {December, 2007},
  liveprogstudyorigins={#('acm' 'immediate AND feedback AND programming'),
		  #('acm' 'exploratory programming')},
  lpssynthesisdomains={educationAndTraining},
  lpssynthesisintendedeffect={creatingAProgram},
  lpssynthesismethodofinquiry={fixedQuantitativeLiveness},
  lpssynthesismotivation={explorationOfAlternatives},
  publisher	= {Academic Press, Inc.},
  url		= {http://dx.doi.org/10.1016/j.jvlc.2006.09.001}
}


@InProceedings{	  mattis2016tlc,
  file		= {live-systems-literature/MattisReinHirschfeld_2016_TransactionLayersControllingGranularityOfChangeInLiveProgrammingEnvironments.pdf},
  publisher	= {ACM},
  address	= {New York, NY, USA},
  pages		= {1 - 6},
  booktitle	= {Proceedings of the International Workshop on
		  Context-Oriented Programming (COP) 2016},
  lpssynthesisdomains={generalApplicationDevelopment},
  title		= {Transaction Layers: Controlling Granularity of Change in
		  Live Programming Environments},
  doi		= {10.1145/2951965.2951969},
  series	= {COP'16},
  location	= {Rome, Italy},
  author	= {Mattis, Toni and Rein, Patrick and Hirschfeld, Robert},
  year		= {2016},
  url		= {http://doi.acm.org/10.1145/2951965.2951969},
  lpssynthesisintendedeffect={system},
  isbn		= {978-1-4503-4440-1},
  abstract	= {Modifying source code in a live programming environment
		  changes the behavior of currently running programs
		  immediately. When complex changes affect multiple locations
		  in the code before reaching a consistent state, running
		  programs are in danger of "de-railing" when their control
		  flow reaches the yet incomplete "construction site".
		  Context-oriented Programming provides layers, which
		  encapsulate code that would otherwise be scattered over
		  many modules and can be activated to jointly adapt program
		  behavior at run-time. We propose to transparently collect
		  and group changes to the code in a COP layer and defer its
		  activation until the programmer deems its change to be
		  completed. Additionally, layer deactivation serves as
		  immediate undo operation on the group of changes. We
		  present and discuss a Squeak/Smalltalk prototype consisting
		  of a code editor, which provides control over when and
		  where such a group of changes is active, and an extension
		  of Squeak's COP implementation ContextS/2 required for
		  representing most code changes in a layer.},
  liveprogstudyorigins={#('acm' 'live programming')},
  lpssynthesismotivation={canNotBeDetermined},
  lpssynthesismethodofinquiry={toolDesign, technicalDesign}
}


@InProceedings{	  mcdirmid2007liu,
  author	= {McDirmid, Sean},
  title		= {Living It Up with a Live Programming Language},
  booktitle	= {Proceedings of the Conference on Object-Oriented
		  Programming, Systems, Languages, and Applications (OOPSLA)
		  2007},
  year		= {2007},
  volume	= {42},
  number	= {10},
  series	= {OOPSLA '07},
  pages		= {623 - 638},
  address	= {New York, NY, USA},
  publisher	= {ACM},
  abstract	= {A dynamic language promotes ease of use through flexible
		  typing, a focus on high-level programming, and by
		  streamlining the edit-compile-debug cycle. Live languages
		  go beyond dynamic languages with more ease of use features.
		  A live language supports live programming that provides
		  programmers with responsive and continuous feedback about
		  how their edits affect program execution. A live language
		  is also based on high-level constructs such as declarative
		  rules so that programmers can write less code. A live
		  language could also provide programmers with responsive
		  semantic feedback to enable time-saving services such as
		  code completion. This paper describes the design of a
		  textual live language that is based on reactive data-flow
		  values known as signals and dynamic inheritance. Our
		  language, SuperGlue, supports live programming with
		  responsive semantic feedback, which we demonstrate with a
		  working prototype.},
  doi		= {10.1145/1297027.1297073},
  file		= {live-systems-literature/McDirmid_2007_LivingItUpWithALiveProgrammingLanguage.pdf},
  isbn		= {978-1-59593-786-5},
  issn		= {0362-1340},
  issue_date	= {October 2007},
  liveprogstudyorigins={{#hull . TextAlive: Integrated Design Environment for
		  Kinetic Typography}, #(#hull 'live coding'), #(#hull
		  'live+programming'), #(#hull 'immediate AND feedback AND
		  programming'), #('dblp' 'live+programming'), #('acm' 'live
		  programming'), #(#hull 'live programming'), #(#hull
		  'live+coding')},
  location	= {Montreal, Quebec, Canada},
  lpssynthesisdomains={generalApplicationDevelopment},
  lpssynthesisintendedeffect={creatingAProgram},
  lpssynthesismethodofinquiry={workbenchDesign, programmingLanguageDesign,
		  technicalDesign},
  lpssynthesismotivation={accessibility},
  url		= {http://doi.acm.org/10.1145/1297027.1297073}
}


@Misc{		  storm2016ll,
  author	= {Storm, Tijs and Hermans, Felienne},
  title		= {Live Literals},
  howpublished	= {Proceedings of the Second Workshop on Live Programming
		  (LIVE) 2016},
  year		= {2016},
  abstract	= {Live programming environments improve programmer
		  experience by providing views of program execution which
		  are continuously, and instantaneously updated. In most
		  existing work on liveness, these views are considered part
		  of the IDE: separate windows, panels, or widgets allow
		  programmers to inspect and interact with live data and
		  program execution. In this paper we present “live
		  literals” where the source code itself is used as vehicle
		  for immediate feedback and direct manipulation. Live
		  literals are like ordinary programming language literals,
		  but they are automatically updated after changes to the
		  code. We illustrate the concept of live literals in
		  Javascript using three applications: embedded spreadsheets,
		  live units tests, and probes.},
  file		= {live-systems-literature/StormHermans_2016_LiveLiterals.pdf},
  liveprogstudyorigins={#('LIVE' 'live programming'),
		  #('liveProgrammingWorkshopProceedings' 'live
		  programming')},
  lpssynthesisdomains={generalApplicationDevelopment},
  lpssynthesisintendedeffect={creatingAProgram},
  lpssynthesismethodofinquiry={programmingLanguageDesign, interfaceDesign},
  lpssynthesismotivation={canNotBeDetermined}
}


@InProceedings{	  aghaee2013lmt,
  lpssynthesisintendedeffect={system, computationResult},
  author	= {Aghaee, Saeed and Pautasso, Cesare},
  booktitle	= {1st International Workshop on Live Programming (LIVE
		  2013)},
  lpssynthesismethodofinquiry={workbenchDesign, interfaceDesign,
		  designPrinciples},
  isbn		= {978-1-4673-6265-8},
  abstract	= {Live programming is a programming style in which the
		  repetitive task of compiling and running the software being
		  programmed is managed automatically. This style can be a
		  helpful practice in End-User Development (EUD) where the
		  nonprofessional end-users are to be supported through
		  techniques and tools that empower them to create or modify
		  software artifacts. Mashups a form of lightweight Web
		  applications composing reusable content and functionalities
		  available on the Web are a popular target for EUD
		  activities on the Web. EUD for mashups is enabled by
		  intuitive composition environments, called mashup tools. In
		  this paper, we introduce live mashup tools, a new class of
		  mashup tools based on the live programming style. We give a
		  comprehensive definition and classification of live mashup
		  tools, giving examples of how well existing tools fit in
		  this category and discuss open research challenges and
		  opportunities.},
  address	= {Piscataway, NJ, USA},
  lpssynthesisdomains={webProgramming, generalApplicationDevelopment},
  doi		= {10.1109/LIVE.2013.6617338},
  liveprogstudyorigins={#('acm' 'live programming'), #(#hull 'live
		  programming'), #('ieee' 'live programming')},
  title		= {Live Mashup Tools: Challenges and Opportunities},
  publisher	= {IEEE Press},
  location	= {San Francisco, California},
  pages		= {1 - 4},
  year		= {2013},
  series	= {LIVE '13},
  file		= {live-systems-literature/AghaeePautasso_2013_LiveMashupToolsChallengesAndOpportunities.pdf},
  url		= {http://dl.acm.org/citation.cfm?id=2662726.2662727},
  lpssynthesismotivation={accessibility}
}

@article{MckayJudy2001Tdio,
issn = {0959-3845},
abstract = {<p> Action research (AR) is not without its critics, and those who reject some of the paradigmatic assumptions embodied in AR maintain that AR is little more than consultancy, that it is impossible to establish causal relationships, that it is difficult to generalize from AR studies, that there is a risk of researcher bias, and that generally speaking, it lacks some of the key qualities that are normally associated with rigorous research. The authors are sensitive to such criticisms, for although they are committed action researchers, they have elsewhere voiced their concerns about the quality of AR practice in the field of information systems. The authors argue that part of the issue concerns the way in which we currently conceptualize AR. In this article, the argument for a deeper and more reflective analysis of the meaning and full implications of AR is developed, culminating in a model of AR being developed that explicitly includes both a problem solving interest cycle and a research interest cycle. Important implications of this new model are articulated, with examples to illustrate these points being drawn from a real-life AR study.</p>},
journal = {Information Technology & People},
pages = {46--59},
volume = {14},
publisher = {MCB UP Ltd},
number = {1},
year = {2001},
title = {The dual imperatives of action research},
language = {eng},
author = {Mckay, Judy and Marshall, Peter},
keywords = {Information Systems ; Research ; Methodology ; Action Research ; Engineering ; Business ; Library & Information Science},
}

@article{DavisonRobert2004Poca,
issn = {1350-1917},
abstract = {Despite the growing prominence of canonical action research (CAR) in the information systems discipline, a paucity of methodological guidance continues to hamper those conducting and evaluating such studies. This article elicits a set of five principles and associated criteria to help assure both the rigor and the relevance of CAR in information systems. The first principle relates to the development of an agreement that facilitates collaboration between the action researcher and the client. The second principle is based upon a cyclical process model for action research that consists of five stages: diagnosis, planning, intervention, evaluation and reflection. Additional principles highlight the critical roles of theory, change through action, and the specification of learning in terms of implications for both research and practice. The five principles are illustrated through the analysis of one recently published CAR study.},
journal = {Information Systems Journal},
pages = {65--86},
volume = {14},
publisher = {Blackwell Publishing Ltd.},
number = {1},
year = {2004},
title = {Principles of canonical action research},
address = {Oxford, UK},
author = {Davison, Robert and Martinsons, Maris G. and Kock, Ned},
keywords = {Canonical Action Research ; Meta‐Analysis ; Research Frameworks ; Interpretivism ; Organizational Change ; Organizational Learning},
}

@inproceedings{proctor2011drools,
  title={Drools: a rule engine for complex event processing},
  author={Proctor, Mark},
  booktitle={International Symposium on Applications of Graph Transformations with Industrial Relevance},
  pages={2--2},
  year={2011},
  organization={Springer}
}

@article{kumar2011rule,
  title={Rule based programming with Drools},
  author={Kumar, Narendra and Patil, Dipti D and Wadhai, Vijay M},
  journal={International Journal of Computer Science and Information Technologies},
  volume={2},
  number={3},
  pages={1121--1126},
  year={2011},
  publisher={Citeseer}
}

@inproceedings{schmidt2008blending,
  title={Blending complex event processing with the rete algorithm},
  author={Schmidt, Kay-Uwe and St{\"u}hmer, Roland and Stojanovic, Ljiljana},
  booktitle={Proceedings of iCEP2008: 1st International Workshop on Complex Event Processing for the Future Internet},
  volume={412},
  year={2008},
  organization={Citeseer}
}

@article{de2011rules,
  title={Rules-based analysis with JBoss Drools: adding intelligence to automation},
  author={De Ley, Erwin and Jacobs, Dirk},
  journal={Proceedings of ICALEPCS 2011},
  pages={790--793},
  year={2011}
}

@article{morovatbusiness,
  title={--Business Rules and DROOLS},
  author={Morovat, Katanosh}
}
