\section{Problem analysis}

The host organization, Khonraad Software Engineering, a subsidiary of Visma, provides mission-critical services focussed on the automation of workflows at the cross-section of local government and healthcare.
Specifically, Khonraad facilitates the mental health care and coercion laws in the Netherlands - WVGGZ, WZD, and WTH - which provide agencies the ability to intervene in domestic violence, psychiatric disorders, and illnesses.

Khonraad's system facilitates reporting and communication between municipalities, police, judiciary, lawyers, mental health care, and many social care institutions.
The system has 15,000 users and is available 24/7. 

Configuration and administration use complex matrices of compliance mechanisms, access user rights and communication settings.
The sensitivity of the personal data, being both medical and criminal, means security is of utmost importance.
The security against data loss, preventing unlawful disclosure and guaranteeing availability, especially during crisis situations, is crucial.
Demonstration of the correctness of the, often changing, configuration is a major concern in the company. 

This configuration is done in a business rule system. 
A business rules engine executes rules at runtime. 
``Rules specify conditions to be monitored and operations that should be executed when certain conditions are detected.
Rather than continuously monitoring the simulation, experts can define and deploy appropriate rules that are automatically evaluated at runtime''\cite{liu2003dios++}. 

Specifically, the rules engine used is JBoss Rules, more commonly known as Drools, from JBoss, a subsidiary of RedHat\cite{browne2009jboss}.
Drools is a framework for Rule-Based development.
It is an open-source production rule system for complex event processing, using the ReteOO and Phreak implementations of the pattern matching Rete algorithm\cite{forgy1989rete}.
The rules are described in a Domain Specific Language (DSL).
These are stored in Drools (.drl) files. 
An example of a DRL file can be seen in listing \ref{listing:drl_file}. 

\begin{lstlisting}[language={[drl]Drools}, caption=Example Drools file., captionpos=b, label=listing:drl_file]
    package org.drools.examples.honestpolitician
 
    import org.drools.examples.honestpolitician.Politician;
    import org.drools.examples.honestpolitician.Hope;
     
    rule "We have an honest Politician"
        salience 10
        when
            // hello
            exists( Politician( honest == true ) )
        then
            insertLogical( new Hope() );
    end
    
    rule "Hope Lives"
        salience 10
        when
            exists( Hope() )
        then
            System.out.println("Hurrah!!! Democracy Lives");
    end
    
    rule "Hope is Dead"
        when
            not( Hope() )
        then
            System.out.println( "We are all Doomed!!! Democracy is Dead" );
    end
    
    rule "Corrupt the Honest"
        when
            $p : Politician( honest == true )   
            exists( Hope() )
        then
            System.out.println( "I'm an evil corporation and I have corrupted " + $p.getName() );
            modify( $p ) { 
                setHonest( false ) 
            }
    end
\end{lstlisting}

Listing \ref{listing:drl_file} gives the Drools engine instructions on what actions to take when something changes in the working memory.
What this toy example does is reacts to when an honest politician is added to the working memory, prints a message celebrating the existence of said politician, corrupts her, gloats in a message and then prints a message of dispair.
The code in listing \ref{listing:drl_file} does the following: 
\begin{enumerate}[topsep=2pt,itemsep=2pt,partopsep=2pt, parsep=2pt]
    \item on line 1 the package statement identifies the rule file
    \item on lines 3 and 4 the import statements describes which facts can be used
    \item the ``We have an honest Politician'' rule on line 6 does the following:
    \begin{enumerate}[topsep=2pt,itemsep=2pt,partopsep=2pt, parsep=2pt]
        \item using salience on line 7 it sets that this rule is to be run before rules with a lower salience
        \item on line 10 it checks the working memory for Politician facts with the honest property equal to true
        \item on line 12, if found then Hope facts will be inserted into the working memory
    \end{enumerate}
    \item the ``Hope Lives'' rule on line 15 does the following:
    \begin{enumerate}[topsep=2pt,itemsep=2pt,partopsep=2pt, parsep=2pt]
        \item line 18 check if any Hope facts exist
        \item on line 20, if found, it prints a message
    \end{enumerate}
    \item the ``Hope is Dead'' rule on line 23 does the following:
    \begin{enumerate}[topsep=2pt,itemsep=2pt,partopsep=2pt, parsep=2pt]
        \item checks if no Hope facts exist on line 25
        \item if none are found, on line 27, it prints a message 
    \end{enumerate}
    \item the ``Corrupt the Honest'' rule on line 30 does the following:
    \begin{enumerate}[topsep=2pt,itemsep=2pt,partopsep=2pt, parsep=2pt]
        \item line 32 checks for any Politician facts with the honest property equal to true, and sets them to the variable \$p
        \item line 33 checks if any Hope facts exist
        \item if both hope and politicians are found on line 35 it prints a message including the \$p variables name
        \item on line 36 to 38 it modifies the fact in working memory represented by \$p to change it's honest property 
    \end{enumerate}
\end{enumerate}

Reasoning over a small number of rules is already surprisingly hard.
Our host organization has many rules and, thus, reasoning about them is particularly challenging.

The Drools language does not have tooling in standard IDEs to help developers to reason about the code.
The problem of a lack of useful visualization for Drools has been known as far back as 2011, when Kaczor, et al\cite{kaczor2011visual} proposed a method of visualising Drools. 
There have also been a few commercial tools to help.
However, these all suffer from the fact that they are not integrated and thus have parsing issues and a lack of immediate feedback. 

We have observed the difficulty that developers have trying to reason about and edit collections of Drools files.
We hypothesize that developers can be presented with different views on their code that will allow them to better understand the code.
The problem we wish to solve - how to improve the ability to reason about large collections of Drools rules - we believe, lends itself to the technique of projectional editing.

Editing programs in a text editor means that you must match the syntax for the parsers to transform the text into an AST.
Projectional editors are editors in which a user edits the abstract syntax tree directly without using a parser\cite{voelter2014generic}.
This potentially allows for almost unlimited language composition and flexible notations.
Like MVC Pattern, changes in one projection of the AST will instantly be visible and editable in another projection\cite{guttormsen2017consistent}.

By using projections to improve feedback whilst coding, we believe that this can reduce the representation impedance mismatch that hampers developer's reasoning.
To build a projectional language in the time available for this project we would need a viable language workbench.
