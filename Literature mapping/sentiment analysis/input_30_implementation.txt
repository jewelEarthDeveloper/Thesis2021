To fully realize the workflow described in Section 2, Deuce+ must comprise three distinct but interrelated components: (Section 3.1) a set of type-directed program transformations informed by common code authoring patterns of functional programmers; (Section 3.2) a syntax constraint language and engine to ensure these transformations are composable and produce stylistically consistent output; and (Section 3.3) a domain-specific language for specifying these transformations.
The first of these components will address Limitation A of Deuce by providing a sizeable set of transformations justifiably rooted in existing programmer behaviors, and the second and third of these components will address Limitation B of Deuce by providing a system for building and composing the transformations that is accessible to any user of the system.
Moreover, with such tools in place, a large library of automatically composable user-defined transformations will be made possible, further combating Limitation A.
3.1 Type-Directed Program Transformations With the strong guarantees of a rich type system, programmers can leverage expressive program transformations to alleviate some of the pains caused by the flexibility of text (as demonstrated by [11]).
As part of the Deuce+ project, we would like to formalize some of the common, implicit techniques that functional programmers use to develop programs by crafting program transformations to perform these authoring patterns automatically.
From personal experience, we have identified a few such transformations, including the Refine Type, Make Progress on Hole, and Make Impossible transformations from Section 2.
However, we would like to design and conduct a user study to observe how functional programmers author code.
Do they start with a skeleton of a solution and later fill in the holes? Or do they, perhaps, write code from the top down? There are myriad other ways code can be written, too, and there may not even be a consensus among functional programmers on this issue; nevertheless, a formal user study is in order to even begin to answer these questions.
In the meantime, we investigate the three aforementioned program transformations and how they relate to some common functional programming authoring patterns, as summarized briefly in Figure 2.
Refine Type.
The Refine Type transformation mirrors the code authoring practice of maintaining code invariants.
After structurally selecting a type, users may activate the Refine Type transformation to narrow down the type’s set of possible values.
Inspired by (but not reliant upon) refinement types [6, 7, 23], the Refine Type transformation prompts the user for an invariant that they wish to maintain about the program, and attempts to refactor the type to ensure that the invariant is satisfied.
For example, consider a functional queue type (left, below) drawn from Chris Okasaki’s Purely Functional Data Structures [16].
Given the queue type on the left and the invariant that |front| >= |back|, Refine Type might suggest to transform the type to that on the right: The first |back| components of front and back are stored together in the list frontBack, and the remaining |front| - |back| elements are stored in the list remainingFront, so it is now impossible to represent a Queue in which |front| < |back|.
(This transformation is a generalization of the approach used in Section 2 to ensure that the lengths of the two lists in the Entries type were equal.) To maintain ease of use and increase backward compatibility, the Refine Type tool might also provide helper functions corresponding to the previous API of the queue: Make Progress on Hole.
The Make Progress on Hole transformation mirrors the code authoring practice of “following the types,” an oft-heard adage in the functional programming community suggesting that the type system can guide the user to implement the task at hand essentially automatically.
While such advice is clearly not universally applicable, the statement does hold some truth to it, as demonstrated by the practice of type-directed programming [1, 26, 27].
After structurally selecting a hole, users may activate the Make Progress on Hole transformation to fill a hole with an expression (that will likely contain further, more specific, holes to fill in the future).
There are at least three type-based approaches that this transformation can rely on to fill holes with helpful expressions: expression templates, typedirected refinement, and program synthesis.
Expression templates are pre-written generic code snippets that can be suggested to the user to fill the hole at hand based solely on the bindings that are in scope and the type of the hole to be filled, as was done to introduce the List.map function in the implementation of the showEntries function in Section 2.
Type-directed refinement is the systematic destructuring of a type into its component types via pattern matching, as was done to pattern match on the entry variable in the implementation of the aforementioned showEntries function.
Another example of type-directed refinement would be, for instance, the filling of a hole of type (a, a) with the expression (??, ??), an expression whose holes have been refined to simpler types (albeit at the cost of introducing a greater number of holes/subproblems).
A final, more general approach to the task of filling holes lies in the practice of type-directed program synthesis, or, generating programs to match a specification (which, in this case, is the type of the hole along with any additional information – such as examples – that the synthesis algorithm may need), as in [5, 10, 12, 18, 19, 20, 21].
Make Impossible.
The Make Impossible transformation mirrors the code authoring practice of making illegal states unrepresentable [4, 15].
At the time of authoring a type, certain code decisions may seem like a good idea that only later reveal themselves to be cumbersome.
For example, a programmer might write a record type representing the state of an application window with the field content : Maybe String (where Nothing represents a closed window).
Some time later, the programmer may realize that windows should save their own position, and thus adds a field position : Maybe (Int, Int) (when the window is closed, they reason, it has no position, so position must be a Maybe type).
But, in enacting this change, the programmer has made representable two states that should be illegal: when either one of the fields is Just something and the other is Nothing.
By structurally selecting the record type and providing the patterns that should be unrepresentable (or by merely structurally selecting the branches in a case expression that should be unrepresentable), the programmer can use the Make Impossible tool to make values of the selected type that match the specified patterns impossible to represent.
In the windowing example from above, the Make Impossible tool would transform the record of Maybe types to Maybe { contents : String, position : (Int, Int) }.
This transformation is made possible by the algebraic nature of datatypes, as used in [14].
While work is still underway to make the intuition rigorous, we may view the Make Impossible transformation on a datatype as operating on the polynomial functor of which the type is a fixed point, represented suggestively as τ − P, where τ is the datatype functor and P is the pattern we wish to eliminate.
For example, viewing record types as product types, we can determine the solution to the windowing example from above using algebraic laws related to this transformation (which are still under investigation):  
