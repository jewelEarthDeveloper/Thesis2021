TSE generates structure editors based on the toString function for a value, with little to no further programmer effort required.
We envision value-centric programming systems that offer editable, domain-specific representations for custom data types, thus affording the programmer a more natural interface for specifying changes on the operation of their program.
At present, we implemented our TSE prototype independent of any of these possible settings.
While our independent implementation highlights TSE’s key techniques, applying TSE to a particular application requires a number of further design decisions, particularly surrounding the handling of actions.
For example, consider the set data structure in Figure 6.
The reference implementation [24] is based on a tree and maintains a number of invariants such as balancing, ordering, and non-duplication.
None of these invariants are expressible in a standard ADT definition alone, and the internal tree structure is not exposed in the toString output ("fromList [2,3,5,7]").
Therefore, only some of TSE’s selection regions are relevant—namely, the terminal items, as reported in Figure 6—and the structural transformations generated by TSE are not meaningful because they do not enforce the set invariants.
TSE does not yet provide an interface for specifying custom insert and remove functions, instead we imagine such an interface would be part of a larger, future IDE.
Beyond action handling for data with complex invariants, our prototype has a number of minor limitations.
First, systems that rely on string tracing ([13], [14]) provide custom implementations of string manipulation functions that correctly propagate dependencies.
We currently only support string concatenation and string length—supplementing our language with additional string functions remains future work.
Finally, our core language and TML do not support nested pattern matches.
How dependency semantics should work for nested patterns is an open question—although a language’s compiler will unnest the patterns [25], different unnestings can result in different dependency traces.
While not uncommon, such ambiguous cases did not occur in our examples.
Adapting TSE to the more common object-oriented setting will require different tracing semantics, because “variants” are handled by virtual method lookups rather than case splits.
Further details about TSE’s algorithm and heuristics will be available in an accompanying technical report.