Playing is an activity humans do since their birth for (self-)learning, to meet others, to be part of communities, to relax, and so forth.
Indeed, we are so used to it that we spend a growing amount of our free time with some form of gaming even in adulthood, and people made a profession out of it [1].
Interestingly, psychologists also observed that by introducing gaming elements and mechanics into “normal”— non-gaming—tasks, it can be possible to promote engagement and even motivate people to achieve certain objectives.
As a matter of fact, an increasing number of activities include gamification elements, very often supported by software applications: Internet banking, sport/activity trackers, and shopping/traveling fidelity cards are all (few) examples of application domains targeted by gamification [2].
A fundamental concern of gameful applications1 is their tailoring to the target domain and users: if a game is detached from the domain interests, the risk is to promote counterproductive/undesired behaviors; similarly, too easy or too complex games could fail engagement objectives due to loss of interest or discouragement, respectively [3].
A direct consequence of the mentioned tailoring needs is the critical contribution and cooperation of application domain and gamification experts: the former ones provide inputs about the engagement issues and desired outcomes, while the latter ones propose corresponding gamification strategies.
Such a cooperation conveys gameful application specifications to be implemented in an appropriate target platform.
In the current state of practice, one available implementation option is to pick up a prepackaged gamification application from a repository [4].
The advantage would be to have a quick development phase limited to configuration purposes, at the price of very limited customization possibilities, unless manually tuning the existing implementation.
Diametrically opposite, a completely new gamified application can be developed from scratch: this solution necessarily entails longer time to market, with the advantage of realizing a fully customized implementation.
Regardless of the choice, the realization and deployment phases introduce an abstraction gap between gamification stakeholders, namely, domain and gamification experts, and the gameful application itself.
In fact, the target application is typically implemented as a collection of rules matching incoming event notifications with corresponding game status updates.
Therefore, developers need to translate game mechanics and other elements into corresponding rules, while the other stakeholders are required to backtrack state changes into corresponding gaming events.
With the growing adoption of gamification in disparate application domains and its spread to a wider range of users, the complexity of gameful software is unavoidably increasing.
In this respect, the abstraction gap between design and realization becomes a critical issue: the implementation phase is more tedious and error-prone, due to the number of rules and the customization needs.
Moreover, maintenance and evolution activities are harder to manage, due to the disconnection between design and realization.
In order to close the gap between design and implementation of gameful applications, we proposed the Gamification Design Framework (GDF) [5, 6].
GDF is a collection of domain-specific languages (DSLs) devoted to the specification, implementation, and deployment of gameful applications.
The framework has been developed by the following three key principles: Separation-of-concerns : a gamification approach can be described by means of several perspectives.
When the complexity grows, an effective way to alleviate it is to manage different perspectives as separate points of view that are later on fused into a complete solution; Correctness-by-construction : given the growth of gamification employment and range of its potential users, the specification of gameful applications becomes increasingly intricate.
In this respect, game rules shall be consistent with mechanisms and elements intended for the target application; Automation : in order to close the gap between design and implementation, the amount of manually written code shall be reduced as much as possible.
Or in the other way around, the degree of automation provided by the framework shall be maximized.
GDF actualizes the mentioned key principles by means of three DSLs that correspond to three abstraction layers any gamified application can be viewed through: (i) the topmost layer defines general mechanics and elements a solution could include, e.g., the concept of point, bonus, challenge, etc.; (ii) the second layer instantiates a subset of the abstract concepts defined on the level above due to the specification of the gameful application under development, for example, number of steps, walker of the week, hundred thousand steps week, respectively; (iii) the third and bottom layer describes the implementation of the concepts above together with their deployment on a gamification engine.
Here, configuration parameters can be set, like thresholds to gain points, bonuses, and awards, the timing of challenges activation, and the assignment of players and teams to the defined tasks.
Moreover, the layers convey generators enabling the automated derivation of implementation code for the gamified application.
GDF is practically realized by means of Jetbrains MPS and is the result of a challenging language engineering process.
In particular, the DSLs included in GDF required a language workbench enabling meta-modeling, semantics specification through generators, and multi-view-based modeling support to ensure the consistency between the different points of view.
During the language engineering process, we soon faced the problem of modeling a system of constraints (as it is a gameful application), which tended to be intractable by adopting diagrammatic approaches.
Moreover, we needed a mechanism enabling the introduction and refinement of high-level gamification solutions and concepts without requiring domain experts to modify the language specification, e.g., by adding new consistency checks.
As a consequence, the DSLs included in GDF convey a text-based concrete syntax that eases the definition of game rules.
Moreover, they exploit the language extension mechanisms provided by MPS to define the interconnections between the different abstraction layers, which implicitly ensures consistency through inheritance relationships.
