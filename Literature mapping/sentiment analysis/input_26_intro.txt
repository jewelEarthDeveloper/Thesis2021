Model-driven development (MDD) has created high hopes for easier systems development and shorter development cycles [27].
The central idea still holds: If we can lift the level of abstraction, such that we see the relevant information of a problem and its solution, then the design of solutions becomes much easier.
Besides, it is possible to discuss the solutions with the experts.
In reality, however, the results were not too promising, (1) because the standard modelling language was chosen to be UML [37]; (2) because models were used as illustrations, and not as specifications; and (3) because of missing or immature tool support.
Therefore, many programmers abandoned modelling.
Modelling can be connected to the expertise when the language used for the model is understandable for the experts, i.e., the language has to be a domainspecific (modelling) language [10].
It is important to use full languages, not only notations without semantics.
This means DSLs need to be executable in order to be useful for modelling, such that they essentially are high-level programs [4, 30, 54].
In this spirit, languages like SDL [23] and executable UML [31] present a high level of abstraction together with executability.
There are attempts to add formality and executability to the OMG MDA framework [6].
This book presents examples of such DSLs, and this chapter looks into how DSLs can be included in computer science teaching.
For systems development, modelling is essential.
Modelling means to develop high-level descriptions of the problems and the solutions.
These descriptions have to translate into running systems that can be used to experiment with the problems and the solutions until a satisfactory result is achieved.
This is only possible if the languages used are formal, allowing to express the important information concisely and formally.
Out of such descriptions, programs can be derivedâ€”either manually or automatically.
In this chapter, we follow an MDD approach that values formality and complete automatic code generation.
The idea of changing the generated code afterward has been abandoned for compilers because it did not bring too good results.
Nowadays, developers rarely touch the code generated by compilers.
The same should be valid for code generated within MDD.
In this view, MDD is closely related to domain-specific languages (DSL), as it is easiest to write concise models using a concise language adapted to a domain [25].
This way, the complexity of the domain is reduced and captured in the concepts of the DSL.
A domain-specific language is a textual or graphical language with abstractions optimized for a domain and with well-defined semantics [53].
A DSL may be preprocessed, embedded, or transformed into other languages for execution, instead of being compiled to machine code using a traditional compiler.
Because the development of DSLs uses high-level descriptions, it is based on the same principles: the language handling tools are generated from high-level descriptions; see [3, 8].
This means MDD is used to define these types of languages.
An important aspect of this approach is to provide the language designer with support for rapid development and automatic prototyping of language support tools and allow for working on a high level of abstraction.
This way, the language designer can focus on the language and use the language definition to generate tools such as editors, validators, and code generators.
A related aspect is the ease of developing DSLs.
Ideally, languages should be put together in a plug-and-play fashion using best-practice language patterns.
This flexibility is achieved by language modularity and the ability to reuse existing languages, allowing language extension and language reuse [51].
Despite the importance of domain-specific languages and the tooling for them, many universities still teach language handling with the main focus on compiler theory.
For example, in Norwegian universities, there is a strong emphasis on compiler theory and little or no focus on meta-modelling in most of the available computer language handling courses [12, 13].
In contrast, we use an approach to teach DSL technology together with MDD technology under a framework of meta-models and generated code, still under the umbrella of computer language handling.
This allows for shifting focus from compiler development to meta-model-based language design and definition.
The primary purpose of this article is to share experiences from teaching metamodel-based language description and to discuss how the tool MPS [24] helps in teaching.
We will also discuss meta-languages for covering the different aspects of a language definition when teaching computer language handling.
The chapter presents a course run at the University of Agder the last 10 years and the experiences with the tools and the learning.
The article will also discuss the course content and design.
 