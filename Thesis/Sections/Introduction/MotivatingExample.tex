\section{Problem Statement}
\label{section:problem_statement}

Rules engines are a place for gathering and executing the rules of a business application.
Rules contain premises and implications.
If the premise of the rules are met then the implications are executed.
A rules engine decides which of the rules to execute.

Drools is one of the leading rules engines.
Drools implements the rules engine paradigm using a version of the Rete algorithm.
The rules are written in a declarative DSL, which will be the subject of this project.
The language, shares an unfortunate characteristic with other rules languages.
Namely, it is verbose and can contain many rules that can interact without an apparent visual connection.
As Forgy\cite{forgy1989rete} points out, for rules languages in general, ``[they] have another property that makes them particularly attractive for constructing large programs: they do not require the developer to specify in minute detail exactly how the various parts of the program will interact''.
This property leads to very large and difficult to reason about collections of implicitly connected rules.

We found that reasoning over a small number of rules is already surprisingly hard.
Our host organisation, Khonraad, a provider of mission-critical cloud software to the municipalities of the Netherlands, has many rules and, thus, reasoning about them is particularly challenging.

One approach to tackle comprehensibility could be to consider Miller's Law\cite{miller1956magical}.
This law states that an average human can hold in his short-term memory 5-9 objects, which is often an argument for succinct code.
The argument is that the developer must store anything that is not immediately in her vision in her memory.
With it being impractical to reason about code that she cannot recall, the fewer relevant items to her reasoning that are out of view, the easier it is to reason about the code.

Through both the experience of the host supervisor and in conversation with the developers at Khonraad, we have observed the difficulty developers have to reason about and edit extensive collections of Drools rules.
We hypothesise that when we present developers with different views on their code, they can better understand it.
The problem we wish to solve - how to improve the ability to reason about sizeable collections of Drools rules - we believe lends itself to the technique of projectional editing.

Projectional editing is a technology implementation that allows users to directly edit the abstract syntax tree through representations of the tree called projections.
This requires no parsing. 
The lack of parsing means that code can be represented without the restrictions of having to be textual.
This property means that code can be edited using unparsable notations, such as mathematical, tabular or graphical notations. 

Language Engineers can use language workbenches (LWB) to design languages.
JetBrains MPS is a LWB to create projectional languages, in their own IDE.
By using projections, developed in MPS, to improve feedback whilst coding, we believe that this can reduce the representation impedance mismatch that hampers the developer's reasoning.

To reason about a large code base of rules engine code effectively, perhaps a different presentation of that code is needed.
The presentations we create should allow a more precise organisation of the code whilst remaining interactive.



