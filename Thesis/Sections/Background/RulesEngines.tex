\section{Rules Engines}

\subsection{What Is A Rules Engine?}

In this section, we will describe what a rules engine is and a little of its history.

The Aristotelian doctrine of essentialism declares that a thing has essential properties and properties that are accidental.
If one takes away the accidental properties of a thing, then the thing remains the thing.
In contrast, if one takes away the thing's essential properties, the thing is no longer the thing.
If the ``thing'' we refer to is a business application, its essential properties are its business rules.

Simply put, business rules are the principles or regulations by which an organization carries out the tasks needed to achieve its goals.
When adequately defined, it is possible to encode these rules into statements that define or constrain some business organizational behaviour.
A rule consists of a condition and an action.
When the condition is satisfied, then the action is performed.
More formally, business rules follow the logical principle of Modus Ponens.

When described like this, one could imagine this as just the ``if-then'' logic frequently used in traditional programming.
One would not be wrong. 
However, representing all the combinatorial outcomes of an extensive collection of rules in traditional programming can become complex.
Each additional rule adds to the fragility.
Additionally, developers tend to distribute rules throughout the source code or database of the application.

We find descriptions of these rules in the design documentation or user manuals.
However, as applications evolve, documentation gets out of sync with the codebase.
Once desynchronization occurs, to know the rules governing the application, one has to navigate the codebase and decode the rules from often scattered locations.

A rules engine is also known as a Business Rules Engine, a Business Rules Management System or a Production Rules System.

Rules Engines are declarative, focussing on the what of the rules, not the how of the execution.
Date\cite{date2000not} describes a rules engine role as ``to specify business process declaratively, via business rules and get the system to compile those rules into the necessary procedural (and executable) code.''
Fowler\cite{Fowler_rulesEngine} describes a rules engine as follows: `` ... providing an alternative computational model.
Instead of the usual imperative model, which consists of commands in sequence with conditionals and loops, a rules engine is based on a Production Rule System.
This is a set of production rules, each of which has a condition and an action ...''.

The goal of a rules engine is to abstract business rules into encoded and packaged logic that defines the tasks of an organization with the accompanying tools that evaluate and execute these rules.
Simply put, they are where we evaluate our rules.
Rules engines match rules against facts and infer conclusions.
Returning to the Modus Ponens comparison:

\begin{tabular}{c@{\,}l@{}} 
    & $p$ \\
\arrayrulecolor{blue!60!green!70}    & $p \to q$ \\\cline{2-2}
$\therefore$         & $q$ \\
\end{tabular}

If the premise $p$ holds and the implication $p \to q$ holds, then the conclusion $q$ holds.
In terms of a rule engine and business rules, this would be:
\begin{enumerate}
    \setlength\itemsep{0em}
    \item the rules engine gathers the data for the premise: $p$
    \item it examines the business rules as the implications: $p \to q$
    \item it executes the conclusion: $q$
\end{enumerate}

Rules engines follow the recognize-act cycle.
First, the match, i.e. are there any rules with a true condition?
Next, they carry out conflict resolution, pick the most relevant matching rules.
They then perform the actions described in the rule.
Then back to the matching step.
If they make no more matches, they terminate the cycle.

Some of the advantages of using a rules engine include:
\begin{itemize}
    \setlength\itemsep{0em}
    \item The separation of knowledge from its implementation logic.
    \item The externalization of business logic.
    \item Rules can be human-readable.
\end{itemize}

In summary, a rules engine is the executor of a rules-based program, consisting of discreet declarative rules which model a part of the business domain.

\subsection{An incomplete history of rules engines}

Rule engines arose from the expert systems of the late 70s and early 80s.
Expert systems initially had three primary techniques for knowledge representation: Rules, frames and logic\cite{jackson1986introduction}.
``The granddaddy'' of the expert systems, MYCIN, relied heavily on rules-based knowledge representation\cite{shortliffe1974mycin} rather than long inference chains.
MYCIN was used to identify bacteria and recommend antibiotic prescriptions.
MYCIN and its progenitor, DENDRAL, spawned a whole family of Clinical Decision Support Systems that pushed the rules engine technology until the early 1980s.
Research into rules engines died out in the 1980s as it fell out of fashion.

Early in their existence, the rules engines hit a limiting factor because the matching algorithms they used suffered from the utility problem, i.e. the match cost increased linearly with the number of examined rules.
Charles Forgy's efficient pattern matching Rete algorithm\cite{forgy1989rete} and its successors solved this problem.
This algorithm works by modelling the rules as a network of nodes where each node type works as a filter.
A fact flows through the filters of this network.
The pre-calculation of this network is what provides the performance characteristics.

The first popular rules engine was Office Production System (OPS) from 1976.
In 1981 OPS5 added the Rete algorithm.
Currently, there are a few rules engines in use.
We show some of the more commonly used ones in table \ref{table:RuleEngines}.

\begin{table}
    \begin{center}
        \begin{tabular}{ |l c |l|l| } 
            \hline
            Product                      &                             & Developer    & licence type   \\
            \hline
            CLIPS                        &\cite{CLIPSProductPage}      & NASA         & open source    \\ 
            Drools                       &\cite{DroolsProductPage}     & JBoss/RedHat & open source    \\ 
            BizTalk Business Rule Engine &\cite{BiztalkProductPage}    & Microsoft    & proprietary    \\ 
            WebSphere ILOG JRules        &\cite{JRulesProductPage}     & IBM          & proprietary    \\ 
            OpenRules                    &\cite{OpenRulesProductPage}  & OpenRules    & open source    \\ 
            \hline
        \end{tabular}
    \end{center}
    \caption{Rules engine products}
    \label{table:RuleEngines}
\end{table}

\input{Sections/Background/drools}

