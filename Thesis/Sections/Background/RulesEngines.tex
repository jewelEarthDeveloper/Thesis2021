\section{Rules Engines}

\subsection{What Is A Rules Engine?}
\label{section:what_is_a_rules_engine}

In this section, we will describe what a rules engine is and a little of its history.

To paraphrase Quine\cite{quine1953three}, the Aristotelian doctrine of essentialism declares that a thing has essential properties and properties that are accidental.
If one takes away the accidental properties of a thing, then the thing remains the thing.
In contrast, if one takes away the thing's essential properties, the thing is no longer the thing.
If the ``thing'' we refer to is a business application, its essential properties are its business rules.

Simply put, business rules are the principles or regulations by which an organisation carries out the tasks needed to achieve its goals.
When adequately defined, it is possible to encode these rules into statements that define or constrain some business organisational behaviour.
A rule consists of a condition and an action.
When the condition is satisfied, then the action is performed.
More formally, business rules follow the logical principle of Modus Ponens.

One could imagine this as just the "if-then" logic frequently used in traditional programming when described like this.
One would not be wrong. 
However, representing all the combinatorial outcomes of an extensive collection of rules in traditional programming can become complex.
Each additional rule, in this traditional style, increases complexity and decreases maintainability.
In essence, it adds to the fragility of the codebase.
Additionally, developers tend to distribute rules throughout the source code or database of the application.

We find descriptions of these rules in the design documentation or user manuals.
However, as applications evolve, documentation gets out of sync with the codebase.
Once desynchronisation occurs, to know the rules governing the application, one has to navigate the codebase and decode the rules from often scattered locations.

A rules engine is also known as a Business Rules Engine, a Business Rules Management System or a Production Rules System.

Rules Engines are declarative, focussing on the what of the rules, not the how of the execution.
Date\cite{date2000not} describes a rules engine role as ``to specify business process declaratively, via business rules and get the system to compile those rules into the necessary procedural (and executable) code.''
Fowler\cite{Fowler_rulesEngine} describes a rules engine as follows: `` ... providing an alternative computational model.
Instead of the usual imperative model, which consists of commands in sequence with conditionals and loops, a rules engine is based on a Production Rule System.
This is a set of production rules, each of which has a condition and an action ...''.

The goal of a rules engine is to abstract business rules into encoded and packaged logic that defines the tasks of an organisation with the accompanying tools that evaluate and execute these rules.
Simply put, they are where we evaluate our rules.
Rules engines match rules against facts and infer conclusions.
Returning to the Modus Ponens comparison:

\begin{tabular}{c@{\,}l@{}} 
    & $p$ \\
\arrayrulecolor{blue!60!green!70}    & $p \to q$ \\\cline{2-2}
$\therefore$         & $q$ \\
\end{tabular}

If the premise $p$ holds and the implication $p \to q$ holds, then the conclusion $q$ holds.
In terms of a rule engine and business rules, this would be:
\begin{enumerate}
    \setlength\itemsep{0em}
    \item the rules engine gathers the data for the premise: $p$
    \item it examines the business rules as the implications: $p \to q$
    \item it executes the conclusion: $q$
\end{enumerate}

Rules engines follow the recognise-act cycle.
First, the match, i.e., are there any rules with a true condition?
Next, they carry out conflict resolution, pick the most relevant matching rules.
They then perform the actions described in the rule.
Then back to the matching step.
If they make no more matches, they terminate the cycle.

Some of the advantages of using a rules engine include:
\begin{itemize}
    \setlength\itemsep{0em}
    \item The separation of knowledge from its implementation logic.
    \item The externalisation of business logic.
    \item Rules can be human-readable.
\end{itemize}

In summary, a rules engine is the executor of a rules-based program, consisting of discreet declarative rules which model a part of the business domain.

\subsection{A short history of the rules engine}
\label{section:rules_engine_history}

Rule engines arose from the expert systems of the late 70s and early 80s.
Expert systems initially had three primary techniques for knowledge representation: Rules, frames, and logic\cite{jackson1986introduction}.
``The granddaddy'' of the expert systems, MYCIN, relied heavily on rules-based knowledge representation\cite{shortliffe1974mycin} rather than long inference chains.
MYCIN was used to identify bacteria and recommend antibiotic prescriptions.
MYCIN and its progenitor, DENDRAL, spawned a whole family of Clinical Decision Support Systems that pushed the rules engine technology until the early 1980s.
Research into rules engines died out in the 1980s as it fell out of fashion.

Early in their existence, the rules engines hit a limiting factor because the matching algorithms they used suffered from the utility problem, i.e., the match cost increased linearly with the number of examined rules.
Charles Forgy's efficient pattern matching Rete algorithm\cite{forgy1989rete} and its successors solved this problem.
This algorithm works by modelling the rules as a network of nodes where each node type works as a filter.
A fact flows through the filters of this network.
The pre-calculation of this network is what provides the performance characteristics.

The first popular rules engine was Office Production System (OPS) from 1976.
In 1981 OPS5 added the Rete algorithm.
Currently, there are a few rules engines in use.
We show some of the more commonly used ones in Table \ref{table:RuleEngines}.

\begin{table}[h]
    \begin{center}
        \begin{tabular}{ |l c |l|l| } 
            \hline
            Product                      &                             & Developer    & licence type   \\
            \hline
            CLIPS                        &\cite{CLIPSProductPage}      & NASA         & open source    \\ 
            Drools                       &\cite{DroolsProductPage}     & JBoss/RedHat & open source    \\ 
            BizTalk Business Rule Engine &\cite{BiztalkProductPage}    & Microsoft    & proprietary    \\ 
            WebSphere ILOG JRules        &\cite{JRulesProductPage}     & IBM          & proprietary    \\ 
            OpenRules                    &\cite{OpenRulesProductPage}  & OpenRules    & open source    \\ 
            \hline
        \end{tabular}
    \end{center}
    \caption{Rules engine products}
    \label{table:RuleEngines}
\end{table}

CLIPS is a very widely used expert system tool. 
Inspired by OPS, it was initially released in 1986 by NASA. 
It uses a mixture of rules and objects, written in C, to model human expertise.

We describe Drools in detail in Section \ref{section:WhatIsDrools}, so we will skip that description here.

BizTalk is Microsoft's middleware offering for the .Net environment. 
Amongst its features is a Business Rule engine using Forgy's Rete algorithm.
It has a simple graphical tool for exploring and building rules and policies, which is what they call their collections of rules.
Microsoft is attempting to migrate customers from BizTalk to Azure App Service Hybrid Connections, which does not have a Rete based rules engine.

ILOG is a cross-platform Business Rules Management System now owned by IBM and rebranded as IBM Operational Decision Management.
Rules are collected as policies in the rules repository.
It is now part of IBMs WebSphere platform and is still actively updated.

OpenRules is an open-source Business Rules and Decision Management System. 
OpenRules, Inc. who offer paid support, training, and consulting services, currently maintain it.
It allows the input of rules files using spreadsheets such as Excel and Google Sheets.

\input{Sections/Background/drools}

