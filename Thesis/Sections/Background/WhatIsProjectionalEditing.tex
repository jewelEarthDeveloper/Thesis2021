\subsection{What is Projectional Editing?}
\label{section:WhatIsPE}

When talking about projectional editing, we are mostly talking in the domain of metaprogramming.
Usually, when we talk about software development, it is the programmer or developer who creates the program and the user who uses it. 
In metaprogramming, we are in the domain of the development of languages.
Here the term ``developer'' could refer to both the creator and the user.
We will distinguish these two roles by referring to the creators of the languages as ``language engineers''.
Thus, when we refer to ``developers'', we mean users of the language that is the product of metaprogramming. 

Traditionally developers write code with text editors or integrated development environments (IDE), which adjust the concrete syntax and allows a parser to create the abstract syntax tree.
A projectional editor inverts this relationship, as a developer edits the abstract syntax tree and allows the IDE to project the concrete syntax.

\subsubsection{Parser Based Editing}

A program is defined using text and edited with a text editor in a traditional parser-based development workflow.
A grammar is a definition of a programming language's formal syntactical rules or concrete syntax.
One derives the lexer and parser from the grammar.
The lexer will turn the text, via a text buffer, into tokens. 
A parser then validates that these tokens, the words of the language, are syntactically correct.
The parser will often then construct a concrete syntax tree and an abstract syntax tree (AST), though not necessarily both.

A concrete syntax tree is the output of a text parsed complying with syntax of the grammar.
It contains many tokens and keywords necessary to be unambiguously parseable that are without any semantic meaning.

An AST is a structure that represents the semantic meaning of the source code, stripped of all the syntactic details.
The parser will carry out some of the name resolutions needed to ensure that the tree represents the references expressed within the source code.
These references turn the tree into a graph.

Compilers use the AST to do subsequent processing, such as transformation, linking, code generation, analysis, and type checking.
Modern IDEs, in the background, also parse the code it is displaying to create an AST that it uses to offer relevant coding assistance.
This assistance is valuable.
Without help from the IDE, learning the concrete syntax of non-trivial languages is demanding.
Exploratory programming is laborious if one must wait until compilation to discover mistakes.

\subsubsection{Projectional Definition}

In the projectional editing paradigm, a semantic model represents the program.
This model requires projectional editing tools to be read and edited.

A projectional editor does not parse any text.
In its place, a developer reads and edits a representation of the AST through a projected notation.
Her editing gestures immediately and directly manipulate the AST.
This editing takes place within predefined and fixed templates called editors.

The principle of projectional editing is familiar to those that use visual programming, like Scratch or Blockly, or graphical modelling tools, such as MetaEdit+.
These tools do not parse pixels to generate their AST.
Instead, they project the underlying models/programs in a view.
They store the model/AST in a custom format rather than its plain text equivalent in a traditional programming language.

Projectional editing is the generalisation of this idea, with the ability to render multiple representations of the program with a wide range of notation styles.

The projection may sometimes seem like a text editor. 
However, this is just acrobatics by the language engineer designing an editor to help developers from traditional text-based languages feel comfortable.
The text is just another type of projection of the AST.
It also may be any other notation that can represent the semantic meaning of the code, such as formulas, graphs, or images.
Projections are not just the notation but also how the user interacts with the projection.
In this sense, the definition of the projections and the IDE/UI overlap.

\subsubsection{What is it Not?}

Projectional editing does not have clearly defined boundaries.
We exclude the following types of tools that sometimes get associated with projectional editing.

A Venn diagram of Model-Based Software Engineering (MBSE) and projectional editing would have a significant overlap.
Here we will not be looking at tools that build code from UML or other MBSE or Model-Driven Engineering (MDE) tools.

Another area mistakenly grouped with projectional editing is Low-code software development environments.
These, however, are only tangentially related.

Most confusing is ``projectional editing'' when referring to a methodology of product line differentiation in code bases.
In addition to having the same name, one of the top products for this product line technique is called PEoPL.
PEoPL uses MPS for development.
Hence, this product is a projectional editor (the paradigm) for product line projectional editing (the methodology).

\subsubsection{How Projectional Editing Works}

As shown in figure \ref{fig:projectionalEditing_loop}, a projectional editor has a model or an AST.
It renders a presentation of the model as a projection.
The developer performs actions on the projection.
Every user editing action maps directly to a change in the AST.

\begin{figure}
    \centering
    \fbox{\includegraphics[width=0.38\textwidth]{Sections/images/projections.png}}
    \caption{Projectional editing loop}
    \label{fig:projectionalEditing_loop}
\end{figure}

To perform the above two items have to be defined by language engineers: The meta-model and the editor.

The meta-model, analogous to the abstract syntax, describes the node concepts and connections used to build the hierarchical structure that is the AST.
This hierarchy can have references to nodes in other branches, so it is a graph although named a tree. 
conceptually this can be seen in figure \ref{fig:ast}.
Each AST must have a root node. 
The nodes, represented by the ovals, can have child nodes.
The child relationship is represented by the downward solid edges.
Nodes can also reference other nodes in the AST, here represented by the dashed edges with arrows showing the direction of the reference.

\begin{figure}
    \centering
    \fbox{\includegraphics[width=0.45\textwidth]{Sections/images/ast.png}}
    \caption{Conceptual AST}
    \label{fig:ast}
\end{figure}

The AST is stored independently of the concrete syntax, often using a database, XML or a proprietary file format.
Rules of the meta-model, such as type systems or scoping rules, must also be described.

Projectional editors avoid the grammars and parsers that define the concrete and abstract syntax in a traditional text-based language.
In text-based languages, parsing transforms the concrete into the abstract.
In projectional editing, the abstract is transformed to concrete using a projection engine that uses projection rules.

Editors combine the projection rules and the gestures or actions to create a change request to the AST.
They are analogous to a concrete syntax.

One of these actions can be typing text. 
However, every string is recognised when entered.
Therefore, there is no tokenising.
Text enters into the templates defined by the editor, and a newly derived projection displays the adjusted underlying AST to the developer.

The projection uses graphical elements to represent the model.
Although often appearing textual, each of the text elements are references to nodes in the AST.

Developers can only interact with the editor via the rigidly controlled code completion menus or gestures and actions.
She builds the AST directly from each interaction she has with the editor.

Nodes are instances of the concepts defined in the meta-model.
Each node has a unique id and points to its defining concept.
It is unambiguous.
References are first-class and defined by the id rather than resolved by name, as in parser-based languages.
Disambiguation happens at the time of input, as the developer chooses from limited legal inputs.

The separation of the abstract and concrete allows the language engineer to implement multiple projections of the same model, using different notations.
The implementation used for projections follows the model-view-controller (MVC) pattern.
Therefore, multiple views of the model can be visible and updateable simultaneously.

Graphical modelling tools, for example, tools for UML modelling, could be seen as specialised implementations of projectional editing.
These modelling tools do not store pictures of the UML diagrams and then parse them to create an AST.
Instead, they store the model, often with extra information about the visual layout, and the image of the UML is projected to the modeller to edit.
Projectional editing generalises this approach to projecting any notation defined by the language engineer.

\subsection{History of Projectional Editing}

Here follows an short history of projectional languages.

In the '70s and early '80s, researchers created several applications for research into the realm of structured editors.
Some examples were: MENTOR\cite{donzeau1980programming}, Incremental Programming Environment\cite{medina1981incremental}, GANDALF\cite{NotkinDavid1985TGp}, Cornell Program Synthesizer\cite{teitelbaum1981cornell}, and Synthesizer Generator\cite{reps2012synthesizer}.
These language-based program editors could force syntactically correct programs. 
This syntactic guidance is achieved through the explicit knowledge of the language. 
These were the precursors to the modern projectional editors. 
They worked by providing templates for each abstract computational unit of the language.
First, one would choose the concept and then fill out the placeholders.

These tools were not good at editing textual notations, which led to a poor user experience.
When they attempted to fix the poor user experience, for example, in the Synthesizer Generator, they reintroduced parsing to parts of the editor, which took away many advantages of the AST's direct editing.

In the late '90s and early '00s, the first forays into commercialising a more generalised version of structured editors, the projectional editors, began.
The first of these was Intentional Domain Workbench (IDW), inspired by Charles Simonyi's 1995 essay ``The Death of Computer Languages, The Birth of Intentional Programming''\cite{simonyi1995death}.
IDW was the product of the company Simonyi founded in 2002 - Intentional Software. 
The Intentional Programming paradigm spotlighted the projectional editing domain, taking it out of the universities and into practice.
Unfortunately, as it was a closed sourced and expensive product, not many papers were written about it.
Ultimately, in 2017 as part of an ``acquihire'', Microsoft bought Intentional Software for its employees and let the product die.

Inspired by a call to action for language orientated programming\cite{dmitriev2004language}, JetBrains embarked in 2004 on a mission to build a product to fulfil that ideal.  
Meta Programming System (MPS) was the outcome of that journey.   
Language engineers created the languages mbeddr, PEoPL, and Realaxy using the MPS platform.  
It currently has an active community of developers and projects both in academia and in the commercial world. 
We chose this tool to be the basis of our projectional editing experiments. 
We will talk about it at greater length in section \ref{section:MPS}.

The last decade has produced a few smaller projectional workbenches.
There are a few open-source, small team projectional projects. 
In 2013 several projectional language workbenches joined MPS in the Language Workbench challenge\cite{erdweg2015evaluating}.
These included M\'as, a web-based projectional editor, which is no longer with us\cite{MasPostMortem}.
Whole Platform\cite{WholePlatformProductPage} is a projectional language workbench plug-in for Eclipse.
Cedalion\cite{lorenz2011cedalion} provides another projectional IDE, specialising in internal DSLs.

More recently, there have been some new products that intersect the projectional domain.
Deuce\cite{hempel2018deuce} and Gentleman\cite{lafontant2020gentleman_SLR} are two recent projection editors that have recently emerged from academia.
The final two mentions in our incomplete history are a little out of left-field. 
Google's Blockly\cite{Blockly_ProductPage} is a tool for making structural editor languages, but only in a block format.
Blockly can create languages similar in style to the scratch language. 
Blueprint visual scripting, a part of the Unreal Engine, is a visual programming language for building concepts such as levels or game assets.
Examples of Blockly and Blueprint can be seen in figures \ref{fig:blockly} and \ref{fig:Blueprint}, respectively.

\begin{figure}
    \begin{center}
        \subfloat[Blockly]{
            \includegraphics[clip,width=0.95\columnwidth]{Sections/images/blockly-2.png}
            \label{fig:blockly}
        }
        
        \subfloat[Blueprint]{
            \includegraphics[clip,width=0.95\columnwidth]{Sections/images/blueprint-2.png}
            \label{fig:Blueprint}
        }
        \caption{Unconventional projectional editors}
    \label{fig:leftfield}
    \end{center}
\end{figure}

\subsection{What Advantages Does Projectional Editing Bring?}
\label{section:projectional_advantages}

Projectional editing gives advantages both to the language engineer and the program developers.
There is a lot of crossover and repetition between papers written on projectional editing regarding its advantages.
To that end, what follows is a synthesis of several papers as to the advantages that projectional editing claims, in no particular order.
Rather than attributing each advantage to each paper, we have made a reference table, table \ref{table:Projectional_Advantages}, of papers proclaiming said advantage. 
 
\begin{table}[h]
    \begin{center}
        \begin{tabular}{ |l | c | l | } 
            \hline
            Advantage                   & \#& Paper(s)   \\
            \hline
            Exploratory programming     & 5 &\cite{klimevs2016domain,ratiu2017experiences,volter2010language,voelter2014towards,hosseinkord2021code}                                                                        \\
            Correctness-by-construction & 7 &\cite{voelter2013dsl,ratiu2019fasten,ratiu2012language,klimevs2016domain,berger2016efficiency,klimevs2016domain,vysoky2018ingrid}                                          \\
            Rich notation               & 22&\cite{pech2021jetbrains,voelter2014supporting,voelter2010language2,voelter2015using,voelter2010embedded,guttormsen2017consistent,voelter2010domain,wortmann2016domain,klimevs2016domain,voelter2013mbeddr,berger2016efficiency,simonyi2006intentional,voelter2016efficient,vysoky2018ingrid,pech2013jetbrains,volter2010language,voelter2014projecting,ratiu2018taming,voelter2015towards,voelter2014towards,simonyi1995death,voelter2019using} \\
            Mixed notation              & 8 &\cite{ratiu2017experiences,voelter2010language2,voelter2015using,voelter2010embedded,guttormsen2017consistent,volter2010language,voelter2014supporting,voelter2014towards}              \\
            Multiple views              & 9 &\cite{klimevs2016domain,voelter2016efficient,voelter2010language2,volter2010language,voelter2010embedded,voelter2010domain,vysoky2018ingrid,volter2010language,voelter2014supporting}   \\
            Language composition        & 23&\cite{voelter2013dsl, meacham2020adaptivevle_SLR, ratiu2019fasten, pavletic2013extensible,voelter2011language,guttormsen2017consistent,berger2016efficiency,voelter2016efficient,voelter2010embedded,ratiu2012implementing,volter2010language,voelter2010language2,voelter2012mbeddr,voelter2011product,voelter2013requirements,voelter2014supporting,voelter2014towards,voelter2015using,voelter2019using,simonyi1995death,vysoky2018ingrid,pech2013jetbrains,voelter2015towards} \\
            IDE functionality           & 3 &\cite{klimevs2016domain,voelter2010embedded,voelter2010language2}                                                                                                \\
            Language evolution          & 1 &\cite{schindler2016language} \\
            Ancillary data              & 5 &\cite{voelter2011product,voelter2013requirements,voelter2019using,volter2010language,voelter2010language2} \\
            \hline
        \end{tabular}
    \end{center}
    \caption{Papers describing advantages}
    \label{table:Projectional_Advantages}
\end{table}

\paragraph{Exploratory programming} As with their progenitors, syntax-directed editors, modern projectional editors help guide a developer unfamiliar with a language.
With their rigid syntax and predefined layout, the editors only allow editing within specific cells of the editor.
This template style means that the developer does not have to worry about the significance of spacing or indentation.
Minutiae of syntactic adornments, such as statement ending semi-colons or enclosing matched brackets, are also not interfering with her exploration of the language space.

When creating code, the editor only presents the developer with legal options within the current context.
As the projection is context-aware, with relevant actions and options suggested and irrelevant ones removed.
Therefore, it is easier for the developer to explore what the language allows her to choose.
Intelligent code completion does not have to be limited to single nodes.
Inserting whole subtrees allows the developer to explore the larger structures of the language.

\paragraph{Correctness-by-construction} A projectional editor prevents her from writing syntactically incorrect code by controlling the interaction between the developer and the AST.
The whole class of syntactical errors is made impossible, with the developer relieved of having to think about special characters and layout.

Typing and scoping errors are removed by only allowing validly typed and scoped options for the developer.
The developer can only select statements that are legal in the context of the location within the AST.

Code does not have to be disambiguated, as this happens at the time of entry by the developer.
If multiple items share the same notation in the editor, the developer chooses the relevant item, thus resolving the ambiguity to what she means rather than what the parser thinks she means.

\paragraph{Rich notation} Constraints associated with textual parsing do not affect the choice of created projections. 
This freedom allows otherwise tricky or impossible to parse notations.
Examples include tabular, mathematical expressions and symbols, diagrams, trees, images, forms, prose, sub- and superscript.
Any visual form or shape that can map onto the AST can represent the program in an editor.

With these notations, one can better reflect the semantics of the program domain, which should aid comprehension.
Mathematics has a rich history of use of notation.
When writing a DSL for the mathematics domain, the domain experts can interact with it in the centuries-old language of their domain.

Of course, the projections can also be projections of text.
Textual projections are often the appropriate projection type.
This suitability is especially true if the domain expertise of the developer is parser-based languages.

\paragraph{Mixed notation} As no parsing is required and ambiguity is not an issue for the underlying AST, it is straightforward to combine different forms of rich notation.
With all notations working on the same editor infrastructure, embedding mathematic symbols within textual projections, within tables within graphical representations is a simple coding pattern.

\paragraph{Multiple views} With the AST being the stored artefact rather than the notation, projectional editing allows the language engineer to define multiple views on the same model optimised for different tasks.
In the practice of software architecture, one presents different views to different stakeholders based on their interests.
Similarly, projectional editing can present experts with various domain expertise views on the model that reflect their needs.
A developer can switch between node projections within an enclosing larger projection to find the one that best suits their current task.

Because the architecture of a projectional editor follows the principles of model-view-controller, it is possible to have multiple simultaneous views of the model.
These multiple views allow the developer to update a projection optimised for writing and immediately see its effect in a projection optimised for understanding.

\paragraph{Language composition} Parser-based languages can support some modularisation and composition, but a projectional editor allows easy and extensive modular language extension and composition.
This ability results from the disambiguation of the nodes of an AST at the time of entry.
If two items with the same syntax are available at the same place, the user will choose the one they require, and therefore the node has an explicitly chosen meaning.

The composition of independently developed languages does not suffer from the syntactic or keyword clashes they would in two grammar defined languages.
Because of the lack of ambiguity, every node referencing the concept that defines it, these languages, when put together, will not have structural or syntactic issues.

Language composition can involve extending an existing language or embedding other languages in a host language without modifying its definition.
The ease of composition and extensions allows building more significant languages out of smaller modules.

\paragraph{IDE functionality} Developers in mature languages are used to the functionality of mature IDEs.
These functionalities include syntax highlighting, intelligent code completion or suggestion, and static analysis for errors and validation.

As projectional languages store the AST rather than the concrete syntax, they require an IDE to edit.
Because of this, when a language engineer designs the language, she also has to design the IDE.
A projection always knows its context because it comes from the AST.
When the editor already knows the meaning of the node it represents, syntax highlighting is simple.
Knowing its context makes it much simpler to suggest intelligent code completions.
Always having a complete AST makes it much easier to validate scope, typing and other hard to implement code validators.

\paragraph{Language evolution} Parsing complicates the evolution of languages. 
For example, adding a new reserved word is difficult without breaking existing code.
Extending a language with new capabilities and syntax in projectional editing is simple.
If the change is syntactic, then the language engineer has to update an editor.
If there is a semantic change, then the language engineer can write a migration in the language to transform a node of one concept to a different type, and the developer would have to run that migration on their code.

\paragraph{Ancillary data} Data added to nodes can augment the AST.
This data is helpful for tasks such as documentation, requirements traceability and product line feature dependencies.

\newpage
\subsection{What are the Disadvantages of Projectional Editing?}
\label{section:projectional_disadvantages}

Whilst fewer papers proclaim the disadvantages of projectional editing, we repeated the approach of the previous section.
Thus, we have synthesised the disadvantages from papers in the following sections and listed citations for these ideas in table \ref{table:Projectional_Disadvantages}.

\begin{table}[h]
    \begin{center}
        \begin{tabular}{ |l | c | l | } 
            \hline
            Disadvantage               & \#& Paper(s)   \\
            \hline
            Low adoption               & 4 &\cite{vysoky2018ingrid,voelter2015using,voelter2015towards,voelter2014projecting} \\
            Unnatural user experience  & 11 &\cite{vysoky2018ingrid,voelter2015towards,voelter2014towards,voelter2012mbeddr,voelter2014projecting,berger2016efficiency,voelter2016efficient,voelter2010embedded,voelter2010language2,schindler2016language,voelter2014supporting} \\
            Ambiguous syntax           & 1 &\cite{guttormsen2017consistent} \\
            Inflexibility              & 2 &\cite{voelter2014towards,voelter2014supporting} \\
            Lack of integration with text ecosystem & 5 &\cite{voelter2012mbeddr,voelter2014towards,voelter2012mbeddr,voelter2014projecting,voelter2014supporting} \\
            Learning curve             & 5 &\cite{voelter2010language2,pech2013jetbrains,voelter2012mbeddr,voelter2014towards,voelter2015using,prinz2021teaching} \\
            Vendor lock-in             & 2 &\cite{voelter2010embedded,voelter2010language2,tomassetti2020reflections} \\
            \hline
        \end{tabular}
    \end{center}
    \caption{Papers describing projectional editing disadvantages}
    \label{table:Projectional_Disadvantages}
\end{table}

We do not consider that the dearth of disadvantages discussed as evidence of projectional editing's superiority.
Our best guess is that those who do not find projectional editing beneficial do not write papers about it.

\paragraph{Lack of adoption} The ideas that proceeded projectional editing - the structured or syntax-directed editor - have been around since the early 1970s yet have failed to be adopted widely.
This argument is a bit of a tautological one, as the low adoption is perhaps an outcome of the other disadvantages of projectional editing.
However, low adoption can lead to a self-reinforcing process, where lack of adoption prevents further adoption.

\paragraph{Inconvenient or unnatural editing} Early attempts at projectional editing presented an inconvenient and unnatural user experience when coding.
These usability challenges, exemplified by the tedious manner of entering code as per the tree's order, compare poorly to parser-based languages.

This poor reputation continues, despite massive improvements in projectional editors.
Whilst there is no debate that projectional editing feels different, some question whether this inconvenience is an intrinsic property or a result of developers, through years of experience, being used to text-based programming.

Modern projectional editors, when using a textual projection, face an ``uncanny valley'' issue.
Whilst trying to simulate a text editor, the developers start to expect all of the functionality of the text-based IDEs.
This expectation is an especially weak trait regarding granularity and restrictions of cursor movement, insertion, deletion, selection, copy and paste, and other interactions with the text.

\paragraph{Ambiguous syntax} One of the selling points of projectional editing, especially concerning language composition, is that there can be no ambiguous syntax.
While there is no ambiguity in the code, there can be ambiguity in the reader's mind.
This ambiguity occurs as the same notation can be projected from different nodes.
For example, if one combined Drools with Basic, the developer might become confused about which language the ``\texttt{Then}'' keyword was coming from.
Consequently, writing ambiguity is replaced by reading ambiguity.

\paragraph{Inflexibility} A developer using a projectional editor has no flexibility in code layout. They may feel they require this for enhanced readability.
The flexibility of the layout is entirely in the hands of the language engineer when she determines the projection rules.

\paragraph{Integration with the text-based world} Projectional editors do not store the definition of the program in the form of a plain-text implementation in the concrete syntax.
Instead, the AST is stored and serialised in a format optimised for the computer rather than the human reader.

This different format of program storage leads to an issue with integration with the text-based ecosystem.
This ecosystem is extensive, as text-based coding has been popular since the 60s.
Two notable examples are code sharing and text diffing for branch merging.
The diffing issue within projectional editing tools is solved.
However, as code-bases often span multiple programming languages and tools, the difficulty of integrating projectional diffing into the software development workflows is still a real problem.

Textual source code can be shared simply by email or on websites. 
This sharing, however, is not easy with projectional code.

\paragraph{Learning curve} For the language engineer, the necessity to develop an editor with a good user experience is much harder work than defining a grammar for a parsed language.
The learning curve for the language engineer is significant, as, by default, she has to think also of the IDE development.

For the developer, especially one with an extensive text-based experience, the different editing style takes some getting used to.

\paragraph{Vendor lock-in} The nature of projectional editing is that what one edits is a projection of the AST, and therefore an IDE is needed to do the projecting and language definition.
The fear of getting locked into a specific concept implementation can negatively impact evaluations of projectional editing by organisations.
To be able to use previously developed languages would require using the same toolset.
Changing to a different toolset for language design would require a significant re-skilling effort.