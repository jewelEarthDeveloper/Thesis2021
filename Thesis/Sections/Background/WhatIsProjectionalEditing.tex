\subsection{What is projectional editing?}

% WIP start

Traditionally programmers write code with text editors, or integrated development environments (IDE), which are basically text editors on steroids.
A projectional editor, also known as structured editor or syntax-directed editor, is a different way to write code.

\subsubsection{parser based editing}

In a traditional, parser-based, development workflow, users use a text editor to represent the program.
Because it is text based then the notation of the language is limited to text.
A grammar is a definition of the formal syntactical rules, or concrete syntax, of a programming language.
The lexer and parser are derived from the grammar.
The text is passed into a text buffer where first a lexer will turn the text into tokens. 
A parser will validates that these tokens, the words of the language, are syntactically correct.
If the tokens are not rejected then the parser will construct first a parse, or concrete syntax, tree and from there, an abstract syntax tree (AST).

An AST is a tree structure that represents the semantic meaning of the source code, stripped of all the syntactic details.
The parser will do some name resolution to take care that references within the source code are represented in the tree. 
This turns the tree into a graph.

Compilers use the AST to do subsequent processing, such as linking, transformation, analysis, type checking, etc.
Modern IDEs, in the background, also parse the code it is displaying to create an AST in order to offer relevant coding assistance.
This assistance is appreciated, because without IDE help learning the concrete syntax of large languages is error prone and exploratory programming is laborious if one has to wait until compilation to discover mistakes.


\subsubsection{projectional definition}

A projectional editor does not parse any text.
In its place, a developer reads and edits the AST through a projected notation.
Her editing gestures immediately and directly manipulate the AST within predefined and fixed layouts.

The principle of projectional editing is familiar to those that use visual programming, like Scratch or Blockly, or graphical modelling tools, such as MetaEdit+.
These tools do not parse pixels to get to their AST. 
They project the underlying models/programs in a view and which they store as the model/AST and not as a plain text equivalent in a traditional programming language.

Projectional editing is the generalization of this idea, with the ability to render multiple representation of the program with a wide range of notation styles.

The projection may be textual. 
It also may be any other notation that can represent the semantic meaning of the code, such as formulas, graphs, or images.
Projections are not just the notation, but also how the user interacts with the projection.
In this sense the definition of the projections and the IDE/UI overlap.

\subsubsection{How projectional editing works}

As shown in figure \ref{fig:projectionalEditing_loop}, a projectional editor has a model or an AST. 
It renders a presentation of the model as a projection. 
The developer performs actions on the projection.
every user editing action is directly mapped on to a change in the AST. 

\begin{figure}[h]
    \centering
    \fbox{\includegraphics[width=0.95\textwidth]{Sections/images/projections.png}}
    \caption{Projectional editing loop.}
    \label{fig:projectionalEditing_loop}
\end{figure}

To perform the above two things have to be defined by language engineers: The Meta-Model and the editor.

The meta-model, analogous to the abstract syntax, describes the node concepts and connection that can be used to build the, hierarchical structure that is the AST.
This hierarchy can have references to nodes in other branches, so, although named a tree, it is actually a graph.
The AST will be stored independently of the concrete syntax.
The tree is often stored with a database, XML or a proprietary file format.

Rules of the meta-model can further be described through behaviours such as type systems or scoping rules.

Projectional editors avoid the grammars and parsers that serve as the definition of the concrete and abstract syntax in a traditional text based language.
Instead of transforming the concrete to the abstract with parsing, the abstract is transformed to the concrete via a projection engine that uses projection rules.
Editors are a combination of the projection rules and the gestures or actions that will create change request to the AST.
They are analogous to the concrete syntax.

One of the actions can be typing text, however, every string is recognized as it is entered, so there is no tokenizing and the text is being entered into the templates defined in the editor.
The resulting changes are displayed to the developer in a newly derived projection of the underlying AST.

The projection uses graphical elements to represent the representation.
Although often appearing textual, each of the text elements are references to nodes in the AST.

Developers can only interact with the editor via the rigidly controlled code completion menus or gestures and actions. 
    
The AST is directly built from each interaction she has with the editor.
Nodes are creates as instances of the concepts defined in the meta-model.
Each node has it's own unique id and points to it's defining concept.
It is unambiguous.
References are first class and defined by the id rather than resolved by name, as in parser based languages.
Disambiguation happens at time of input, as the developer choses from limited legal inputs.

The separation of the abstract and concrete allows the language engineer to implement multiple projections of the same model, using different notations, each node of the AST taking having the design she envisions.
The pattern used for projection is similar to MVC, so multiple views of the program can be visible and updateable at the same time.

Graphical modelling tools, for example for UML modelling, are specialized implementations of projectional editing.
UML diagrams are not stored as pictures and whose pixels are parsed to create an AST.
Instead the model is stored, often with extra information about visual layout, and the image of the UML is projected to the modeller to edit.
Projectional editing generalizes this approach to projecting any notation defined by the language engineer.


\subsubsection{What advantages does projectional editing bring?}

Projectional editing gives advantages both to the language engineer and the program developers.
There follows, in no particular order, a number of advantages of projectional editing synthesised from the literature mapping described in the chapter \ref{chapter:Method}.[TODO: make sure I describe the literature mapping].
 
\paragraph{Exploratory programming\cite{klimevs2016domain,ratiu2017experiences,volter2010language,voelter2014towards}}
As with their progenitors, syntax-directed editors, modern projectional editors help guide a developer unfamiliar with a language.
The defined editors with rigid syntax and pre-defined layout mean that only specific cells within the editor can be edited.
This template style means the she does not have to worry about significance of spacing or indentation.
Minutiae of syntactic adornments, such as statement ending semi-colons or enclosing matched brackets, are also not interfering with her exploration of the language space.

When creating code the developer is only presented with legal options within the current context.
As the projection is context aware, relevant actions or options can be suggested and irrelevant ones can be removed.
Thus, it is easier for her to explore which options and actions the language allows her to choose.
Intelligent code completion does not have to be limited to single nodes. 
Whole subtrees can be inserted allowing the developer to explore the larger structures of the language.

\paragraph{Correctness-by-construction}
A projectional editor, by controlling the interaction between the developer and the AST, prevents her from writing syntactically incorrect code.
The whole class of syntactical errors are made impossible, with the developer relieved of having to think about special characters and layout.
Typing and scoping errors are removed by only allowing validly typed and scoped options for the developer.

The developer is only able to select statements that are legal in the context of the location within the AST.
Code does not have to be disambiguated, as this happens at time of entry by the developer.
If there are multiple items that share the same presentation in the editor, the developer chooses the relevant item, resolving the ambiguity to what she means rather than what the parser thinks she means.

\paragraph{Rich notation}
The choice of projection is unconstrained by the restrictions of code that needs to be parsed from a textual source.
This freedom opens up diverse otherwise difficult or impossible to parse notations.
Examples include tabular, mathematical expressions and symbols, diagrams, trees, images, forms, prose, sub- and superscript.
Any visual form or shape that can be mapped to the AST can be used to represent the program in an editor.

With these notations one can better reflect the semantics of the program domain, which should aid comprehension.
Mathematics has a rich history of use of notation.
When writing a DSL for the Mathematics domain, the domain experts can interact with it in the centuries old language of their domain. 

Of course the projections can also be projections of text.  
This is often the appropriate projection type if the developer interacting with the language's domain expertise is parser-based languages.

\paragraph{Mixed notation}
Because no parsing is required, the different forms of rich notation can be combined without the need to create a unifying parser.
With all notations working on the same editor infrastructure mathematic symbols can be embedded within textual projections, within tables within graphical representations.
As ambiguity is not an issue for the underlying AST, then mixing different notations becomes much easier.

\paragraph{Multiple views}
With the AST being the stored artefact rather than the notation, projectional editing allows the language engineer to define multiple views on the same model optimised for different tasks.
Similar to how software architecture presents different views for different stakeholders interests, the same notational diversity can be achieve with specific editors targeted to experts in the various parts of the domain.
A developer can switch between different projections of a node within a larger projection, to find the one that best suits their current task.

Because the architecture of a projectional editor follows the principles of model view controller, it is possible to have multiple simultaneous views of the model.
This allows the developer to update a projection that is optimised for writing and immediately see its effect in a projection optimised for understanding.

\paragraph{Language composition}
Parser-based languages can support some modularization and composition, but a projectional editor allows easy and extensive modular language extension and composition.
This is a result of the nodes of an AST being disambiguated at entry rather than through a parser.
If two items with the same syntax are available at the same place, then the user will choose the one that they require, and therefore the node has an explicitly chosen meaning.

The composition of independently developed languages does not suffer from the syntactic or keyword clashes they would in two grammar defined languages.
Because of the lack of ambiguity, every node referencing the concept that defines it, these languages, when put together, will not have structural or syntactic issues.

Composition can involve extending an existing language or embedding other languages in a host language without modifying the definition of said language.
The ease of composition and extensions leads to the advantage of being able to build larger languages out of smaller modules.

\paragraph{IDE functionality}
Developers in mature languages are used to the functionality of mature IDEs.
These functionalities include syntax highlighting, intelligent code completion or suggestion, and static analysis for errors and validation.
As projectional languages store the AST rather than the the concrete syntax, they require an IDE to edit.
Because of this, when a language engineer designs the language she also has to design the IDE.

Because the projection is based on the AST it always knows it's context.
When the editor already knows the meaning of the node it is representing, then syntax highlighting is simple.
From knowing it's context, it makes it much simpler to suggest intelligent code completions.

Always having a complete AST makes it much easier to validate scope, typing and other hard to implement code validators.

\paragraph{Language evolution}
Extending a language with new capabilities and syntax is simple.
If the change is syntactic then the language engineer has to update an editor.
If there is a semantic change then the language engineer can write a migration in the language, to transform a node of one concept to a different type, and the developer would have to run that migration on their code.

\paragraph{Ancillary data}
Data can be added to nodes that can augment the AST. 
This has shown to be useful for documentation, requirements traceability and product line feature dependencies.












%DISADVANTAGES
This idea emerged as early as in 1970s, but it failed to get adopted widely, mostly due to inconvenient and unnatural way of manipulating code.

The freedom in defining the concrete syntax is not problematic for the computer, but it can cause problems for the language user 
Ambiguous syntax is not only a problem for parsers, but a problem that affects humans as well. 
but there are also downsides to this syntax ambiguities do not only affect parsers, but humans as well 

This notational flexibility leads to drawbacks.
In a ParE, a program can always be typed exactly the way it looks by typing the sequence of characters one by one.

ProjE does not support custom layout (SM.6) – the representation is determined completely by the projection rules.

Historically Projectional editors have had useability challenges and weren't used much in practice.  

Traditionally, projectional editors were tedious to use and were hardly adopted in practice.



However, ProjEs have traditionally had two problems.
First, for notations that look textual, users expect that the editing behavior resembles classical text editing as much as possible 
Second, ProjEs cannot store programs in the concrete syntax – otherwise, this syntax would have to be parsed when programs are loaded into the editor.
Instead, programs are stored as a serialized AST, often as XML. 

However, the challenge in projectional editing is making the editing experience convenient and productive.
Traditionally, projectional editors have had a bad reputation because the user experience in editing programs was unacceptable.


Traditionally, projectional editors were hard to use and were not adopted much in practice.

Projectional editing is often considered a drawback because the editors feel somewhat different and the programs are not stored as text, but as a tree (XML).

Traditionally, PEs also have drawbacks, which is why they have not seen much adoption despite their advantages.

The following two drawbacks are the most important.
First, for languages that use a textual syntax, users expect the editor to behave like regular, characteroriented text editors.
Since PEs do not work with sequences of characters, this can be a challenge. 


The second challenge of PEs is infrastructure integration.
PEs do not store programs as text, because this would re-introduce parsing and hence negate the advantages.
Instead, the AST is persisted, typically as XML.
For use in practice, the integration of these XML files with version control systems must be addressed: diff/merge must be supported using the concrete, projected syntax.


Textual source code can be written in any text editor and simply be shared.
However, a projection can still be ambiguous or confusing to the user.
Some projections are really bad and should be rejected, which this paper advocates.

Thus, it is crucial that projectional editors do not negatively impact editing efficiency for textual notations.

This is their weak spot: for textual notations, projectional editors behave differently from what developers know from traditional text editors in terms of the granularity and restrictions of code edits and code selections.

The main drawback of projectional editors is their questionable usability.
Projectional editing can also be used for a syntax that is textual or semi-graphical (mathematical notations for example).
However, since the projection looks like text, users expect interaction patterns and gestures known from "real text" to work (such as cursor movements, inserting/deleting characters, rearranging text, selection).

A projectional editor has to "simulate" these interaction patterns to be usable. 
However, since the projection looks like text, users expect interaction patterns and gestures known from "real text" to work.
For a projectional editor to be useful, it has to "simulate" interaction patterns known from real text.


Because projectional languages by definition need an IDE for editing (it has to do the projection!), language definition and extension always implies IDE definition and extension.


As the examples below will show, projectional editing has a number of intriguing advantages, but there is also a price to pay: this price is the additional effort that goes into defining a nicely usable editor.

This transition requires significant training and it can be a cause of resistance.
By improving the editing experience we can reduce this risk.



Traditionally, projectional editors have also had disadvantages relative to editor usability and infrastructure integration; those are discussed in [3].
One characteristic of projectional editors is that the language structure strictly determines the structure of the code that can be written in the editor.


%EXAMPLES
At the same time, projectional language workbenches like MPS [57] and Intentional [47]

Second, Behringer, Palz, and Berger (2017) present Projectional Editing of Product Lines (PEoPL), a DSL that enables multiple projections for variability mechanisms.

Such editors have existed since the 1980s and gained widespread attention with the Intentional Programming paradigm, which used projectional editing at its core.

Projectional editing, also known as structured editing or syntax-directed editing, is not a new idea; early references go back to the 1980s and include the Incremental Programming Environment [32], GANDALF [35], and the Synthesizer Generator [39].
Work on projectional editors continues today: Intentional Programming [44, 18, 45, 14] is its most well-known incarnation.
Other contemporary tools [20] are the Whole Platform [9], M´as [3], Onion, and MPS [4]

Projectional Editors from the 1980s.
GANDALF [35] and the Incremental Programming Environment (IPE) [32] do not attempt to make editing textual notations efficient; for example, they lack support for linear editing of tree-structured expressions.
The Synthesizer Generator [39] avoids the use of projectional editing at the fine-grained expression level, where textual input and parsing is used.
While this may improve editing efficiency, it risks the advantages of projectional editing, because language composition at the expression level is limited.
Another work that implements and uses a DSL within the Synthesizer Generator [37] concludes: “Program editing will be considerably slower than normal keyboard entry, although actual time spent programming non-trivial programs should be reduced due to reduced error rates.”

The Intentional Domain Workbench (IDW) is the most recent implementation of the Intentional Programming paradigm [44, 18], supporting diverse notations [45, 14].
Since it is a commercial, closed-source project without widespread adoption yet, we cannot easily study it or survey its users.


All contemporary projectional editors are part of language workbenches

An early example of a projectional editor is the Incremental Programming Environment (IPE) [16].
It supports the definition of several notations for a language as well as partial projections, where parts of the AST are not shown.
However, IPE did not address editor usability; to enter 2+3, users first have to enter the + and then fill in the two arguments.
Another early example is GANDALF [17]; the report in [20] states that the authors experienced similar usability problems as IPE: “Program editing will be considerably slower than normal keyboard entry, although actual time spent programming non-trivial programs should be reduced due to reduced error rates.”
The Intentional Programming project [9, 22] has gained widespread visibility and has popularized projectional editing; the Intentional Domain Workbench (IDW) is the contemporary implementation of the approach.
IDW supports diverse notations [7, 23].

Scratch [15] is an environment for learning programming.
It uses a projectional editor, but does not focus on textual editing; it relies mostly on nested blocks/boxes.
So does GP [18].
Textual notations, and thus grammar cells, are not relevant.
Prune [2] is a projectional editor developed at Facebook.
The goal is explicitly to not feel like a text editor; the hypothesis is that tree-oriented editing operations are more efficient than those known from text editors.
While this is an interesting hypothesis, our considerable experience with using projectional editing in real projects has convinced us that this approach is not feasible; hence the work described in this paper.

The Synthesizer Generator [21] is a projectional editor which, at the fine-grained expression level, uses textual input and (regular, textual) parsing.
While this improves usability, it destroys many of the advantages of projectional editing in the first place, because language composition and the use of non-textual notations at the expression level is limited.

Eco [10] relies on language boxes, explicitly delineated boundaries between different languages used in a single program (e.g., the user could define a box with Ctrl-Space).
Each language box may use parsing or projection.
This way, textual notations can be edited naturally, solving the usability issues associated with editing text in a projectional editor.

Lamdu [5], a functional, projectional language (no paper)

. Dataflow visual programming languages, such as Blueprints in the Unreal Engine [2], are often domain-specific.


Early syntax-directed source code editors included Interlisp-D (for Lisp’s limited syntax) and Emily[1] (for PL/I’s rich syntax).

deuce: lightweight structured editing in sketch-n-sketch

Blockly: https://developers.google.com/blockly



An early example of a ProjE is the Incremental Programming Environment (IPE) [4].
Another early example is GANDALF [5], which generates a ProjE from a language specification.

The Synthesizer Generator [7] is also a ProjE.
However, at the fine-grained expression level, textual input and parsing is used.
While this improves usability, it destroys many of the advantages of projectional editing in the first place, because language composition at the expression level is limited.
In fact, extension of expressions is particularly important to tightly integrate an embedded language with its host language [8].

The Intentional Programming [2,3] project has gained widespread visibility and has popularized projectional editing; the Intentional Domain Workbench (IDW) is the contemporary implementation of the approach.
IDW supports diverse notations [9,10].


Language boxes [11] rely on explicitly delineating the boundaries between different languages used in a single program (e.g., the user could change the box with Ctrl-Space).
Each language box may use parsing or projection.













% WIP End