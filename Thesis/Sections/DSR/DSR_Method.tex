\section{Method - Drools in MPS}
\label{section:dsr_method}

Even though Drools is a relatively small DSL, we did not need to implement all the functionality to answer our questions.
For this reason, we first created a pilot study language to asses the possibilities of projectional solutions to our question.
We finally created a larger, but incomplete versions of Drools, in which we could create projections that would be recognisable to experienced Drools users.

\subsection{Really Simple Drools Language}
In our pilot study language we created a simple approximation of the Drools language with which to create our first projections.
We called this language ``Really Simple Drools'' (RSD).
We describe this pilot study language here, as it contains many of the projections we considered for our research question.

\paragraph{\texttt{File}} RSD, like Drools itself, has a \texttt{File} as its root node.
The \texttt{File} only contains \texttt{FactDeclaration} nodes and \texttt{Rule} nodes.

\paragraph{\texttt{FactDeclaration} and \texttt{FactProperty}} In Drools, a \texttt{FactDeclaration} represents a Java Bean with its child properties, which can also have their child properties, ad infinitum.
In RSD, we limited properties to allow only boolean values.
We decided this because fact selection is a predicate and thus can only return a boolean.
By only allowing booleans, we also simplify the operations allowed on the \texttt{FactProperty}.

\paragraph{\texttt{Rule}} We only simulated the Left-hand side, or the ``\texttt{when}'' conditions, of a Drools Rule for the \texttt{Rule} Concept.
We believed this would provide us with compelling options for projections and did not want to overcomplicate this pilot project.

An RSD Rule consists of a collection of conditions.
Should all those conditions return \texttt{true}, then the \texttt{Rule} is selected.

\paragraph{\texttt{AbstractCondition}} A condition operates on one or more \texttt{FactSelectors}.
There are four condition types \linebreak\texttt{ExistsCondition}, \texttt{NotCondition}, \texttt{AndCondition}, and \texttt{OrCondition}.
\texttt{ExistsCondition} and \texttt{NotCondition} are unary conditions and evaluate one \texttt{FactSelector}.
\texttt{AndCondition} and \texttt{OrCondition} conditions evaluate two \linebreak\texttt{FactSelectors}.

\paragraph{\texttt{FactSelector}} A \texttt{FactSelector} consists of a reference to a \texttt{FactDeclaration} and a collection of \linebreak\texttt{AbstractPredicates}.
If the fact exists and all the predicates evaluate to \texttt{true}, then the \texttt{FactSelector} evaluates to \texttt{true}.

\paragraph{\texttt{AbstractPredicate}} The predicate is an operation on a \texttt{FactProperty}, to which the Concept has a reference.
Because \texttt{FactProperty} represents a boolean value, the only predicate operations are ``And'', ``Or'', ``Is'', and ``Not''.

Figure \ref{fig:RSDDiagram} shows the Concept hierarch for this straightforward implementation.

\begin{figure}
    \centering
    \fbox{\includegraphics[width=0.95\textwidth]{Sections/images/ReallySimpleRuleLanguage4.png}}
    \caption{RSD concept hierarchy}
    \label{fig:RSDDiagram}
\end{figure}

We realised this design in MPS.
As the aim was to attempt different projections, we did not initially optimise for editing.
The Structure is as shown in figure \ref{fig:RSDStructure}.
We have here translated our Conceptual design of the RSD into MPS Concepts.
There is an almost one to one relationship with our concept hierarchy diagram.
The one difference is that the references in the concept hierarchy diagram, represented by the dashed red lines, are represented in our MPS Structure by SmartRef Concepts \texttt{FactDeclarationSmartRef} and \texttt{FactPropertySmartRef}.

\begin{figure}[h]
    \centering
    \fbox{\includegraphics[width=0.40\textwidth]{Sections/images/RSRStructrure.png}}
    \caption{RSD Language Structure}
    \label{fig:RSDStructure}
\end{figure}

The definition of the editors are shown in figure \ref{fig:RSDEditors} on the following page.
The first editor describes the \texttt{File}. 
It show that the first line will have the text ``rule file name: '', followed by the name of the file.
Following and empty line, there is a vertical listing of the \texttt{FactDeclaration} nodes stored in the ``facts'' child of the \texttt{File}.
Thereafter is another empty line followed by a vertical listing of the \text{Rule} nodes stored in the ``rules'' child.

The next editor shown is the editor of the \texttt{FactDeclaration} Concept.
Each \texttt{FactDeclaration} will be shown on a single line starting with the word ``fact'' followed by its name, then, between parentheses, a horizontal, comma separated list of its \texttt{FactProperty} property children.

The subsequent editor describe the \texttt{Rule} Concept. 
The layout it describes is similar to that of a Drools rule, with the first line being ``rule'' followed by the rule name in inverted commas.
There is a hardcoded indented ``when'', followed by a further indented vertical list of the condition children.
This is then followed, at appropriate levels of indentation, by three hard coded lines, of ``then'', a comment as a place holder for the right hand side of a normal Drools rule, and ``end''.

Next we show one of the \texttt{AbstractCondition} Concepts, in the case the \texttt{AndCondition}.
This displays the two \texttt{FactSelector} children separated by ``and'' and surrounded by parentheses.

The editor for the \texttt{FactSelector} Concept displays the fact child which is a \texttt{FactDeclarationSmartRef}, for which we do not show it's editor here, but in this case shows the name of the \texttt{FactSelector} that it is referencing.
This is then followed by a horizontal, comma separated list of the \texttt{AbstractPredicate} nodes stored in the predicates children.

The final editor we show is an example of an \texttt{AbstractPredicate}, specifically an \texttt{OrPredicate}, which shows the two properties separated by a ``||'' symbol.
The properties are \texttt{FactPropertySmartRef} nodes and they will just display the name of the \texttt{FactProperty} to which they point.

\begin{figure}
    \centering
    \fbox{\includegraphics[width=0.66\textwidth]{Sections/images/RSREditors_P2.png}}
    \caption{Editors}
    \label{fig:RSDEditors}
\end{figure}

\newpage

The result of the editors can be seen in figure \ref{fig:RSDProgram}, which shows an example of our default Drools-like text projection. 
This projection is of the root AST a \texttt{File} node called ``DossierSleutelbos''.
It has 4 \texttt{FactDeclaration} children and 3 \texttt{Rule} children.
The \texttt{FactDeclaration} nodes called ``Dossier'', ``Episode'', and ``Milestone'' each have 2 child \texttt{FactProperty} children, whilst ``DroolsContext'' has none.

The \texttt{Rule} node ``0'' has 2 \texttt{ExistsCondition} nodes containing \texttt{FactSelector} node children with \linebreak\texttt{FactDeclarationSmartRef} nodes referencing the \texttt{FactDeclaration} nodes ``Dossier'' and ``DroolsContext''.

The \texttt{Rule} node ``[WVGGZ/CM] start CM Procedure'' points to the ``Dossier'' \texttt{FactDeclaration}, as well as having 2 predicates.
The first predicate is an \texttt{IsPredicate} with a \texttt{FactPropertySmartRef} node pointing to the ``isWvGGZ'' \texttt{FactProperty}.
The other predicate is a \texttt{NotPredicate} node pointing to the ``hasRunningEpisode'' \texttt{FactProperty}.

The final \texttt{Rule} node has a complex nesting of \texttt{AbstractCondition} nodes.
The first is an \texttt{OrCondition} which contains an \texttt{ExistsCondition} in its left hand side and an \texttt{AndCondition} on the right.
The right hand side node contains an \texttt{ExistsCondition} node on both the left and right sides. 

\begin{figure}[h]
    \centering
    \fbox{\includegraphics[width=0.66\textwidth]{Sections/images/RSRProgram_P.png}}
    \caption{RSD program}
    \label{fig:RSDProgram}
\end{figure}

\newpage

Part of our research question is using projections for reasoning about large files.
To answer this, we needed to simulate a large file.
To do this, we had to enter many \texttt{Rule} nodes.
As this becomes tedious, we added some editing aids, including substitute menus, to speed up the entry of Conditions, as shown in figure \ref{fig:RSDSubstituteMenu}.

\begin{figure}[h]
    \centering
    \fbox{\includegraphics[width=0.66\textwidth]{Sections/images/RSRSubstituteMenu_P.png}} 
    \caption{RSD substitute menu}
    \label{fig:RSDSubstituteMenu}
\end{figure}

This image shows that we originally had to select an \texttt{ExistsCondition} Concept and select the \linebreak\texttt{FactDeclaration} for the Condition.
After adding the substitute menu, we could immediately select the \texttt{FactDeclaration} we wanted, and the \texttt{ExistsCondition} would automatically wrap it with an \texttt{ExistsCondition} node.

The code to do this is shown in the section "wrap substitute menu".
What is does is when it encounters the possibility to input an \texttt{ExistsCondition} in a menu, it replaces it with the default menu for the \linebreak\texttt{FactDeclarationSmartRef}.
MPS handles SmartRefs in menus by showing all the possible reference items available.
When the user picks the reference item this code will then create a new \texttt{ExistsCondition} with a new \texttt{FactSelector} containing the chosen \texttt{FactDeclarationSmartRef}, to insert at that point in the AST.
This saves several keystrokes, as otherwise we manually first had to insert a \texttt{ExistsCondition} followed by a \texttt{FactSelector} before filling the fact child.

Finally, we added a Constraint to scope the \texttt{FactProperties} in \texttt{Predicates} to the \texttt{FactDeclarationSmartRef} chosen in the \texttt{FactSelector}.
This scope Constraint made it much easier to select \texttt{FactProperties} in the \linebreak\texttt{Predicates}, as indicated in figure \ref{fig:RSDConstraint}.

\begin{figure}
    \centering
    \fbox{\includegraphics[width=0.66\textwidth]{Sections/images/RSRConstraint_P.png}}
    \caption{RSD scoping constraint}
    \label{fig:RSDConstraint}
\end{figure}

The figure shows that before adding the scoping constraint, it showed a list with dozens of potential \texttt{FactProperties}, that represented all the \linebreak\texttt{FactProperties} in the model.
After adding the constraint, it only shows the two \texttt{FactProperties} associated with the \texttt{FactDeclaration} referenced in the \texttt{FactSelector}.
This is achieved in the code in the scope method.
This first finds the relevant \texttt{FactDeclaration} in the from the \texttt{FactSelector} we are at in our current location in the AST.
from this it returns a list of properties as a \texttt{Scope}.

Thus, we have described the entire implementation of the Really Simple Drools Language.

After implementing the language, we wrote a program with many rules.
This program on which we will experiment with the different projections.

We discuss the alternative projections in the results section \ref{section:dsr_results}.

\newpage
\subsection{Drools-Lite Language}
\label{section:DroolsLite}

The RSD was useful as an initial language. 
However, it suffered from two significant issues.
Firstly, its limitations as a language were so substantial that it could not handle many necessary scenarios.
Secondly, our projections would be validated by developers with Drools experience, and RSD would be too alien to them.
For this reason, we needed to create a projectional language that was much closer to the Drools language.

\begin{figure}
    \centering
    \fbox{\includegraphics[width=0.90\textwidth]{Sections/images/DroolsLiteStructure.png}}
    \caption{Drools-Lite structure}
    \label{fig:DroolsLiteDiagram}
\end{figure}
 
Our following Language, Drools-Lite, contains many more of the features of Drools.
Our method of selecting the features involved implementing the examples delivered with Drools (including the corrupt politician example shown in section \ref{section:WhatIsDrools}).
We would implement just enough features to complete the examples.
Whenever we had any queries about designing Concepts, we referred to our analysis of the Drools Language, shown in appendix \ref{appendix:DroolsConceptHierarchy}.
We show the preliminary design we achieved using this method in figure \ref{fig:DroolsLiteDiagram} on page \pageref{fig:DroolsLiteDiagram}.
Later, there were some places we diverged a little from our design.
We merged and decoupled our Concepts when we thought it would simplify the code.

\paragraph{\texttt{RuleFile}} The \texttt{RuleFile} level statements contain \texttt{Facts}, \texttt{Globals} and \texttt{Rules}.
It also contains semantically unimportant empty lines.

\paragraph{Fact} A \texttt{Fact} has a \texttt{type} property.
We implement the \texttt{type} property using a \texttt{ClassifierType} from the MPS BaseLanguage.
This implementation allows the \texttt{RuleFile} to refer to BaseLanguage classes implemented in the same solution and from Java JAR files.

We created a smart reference Concept for this to take advantage of built-in MPS UI functionality.
A smart reference is a node with a single reference of 1:1 cardinality.
The editor builders know how to select which nodes are in scope to display to the developer if one uses this object rather than directly referencing the node it refers to.

\paragraph{FactProperty} In RSD, we had \texttt{FactProperties} as children of \texttt{Facts}.
Now that our \texttt{Facts} refer to actual classes (\texttt{ClassifierType}), our \texttt{FactProperties} should reflect this.
To do this, the Concept itself only references an \linebreak\texttt{InstanceMethodDeclaration}, the MPS BaseLanguage's definition of a method signature.
We scoped the Concept to only show properties associated with a selected \texttt{Fact}.

Drools interacts with Java objects as if they are Java Beans.
To simulate this, we limited the scope of the properties to just getters, i.e., methods that start with ``get'' or ``is'', and used a Behavior to make sure they are displayed without the ``get'' or ``is'' prefix.
We also made a smart reference for this Concept.

Another option for achieving this is to have wrapped the \texttt{ClassifierType} and referenced its related \linebreak\texttt{InstanceMethodDeclarations}.
We would have then had to limit the functionality of these items from the BaseLanguage.
Whilst this allows the functionality we wished for, we feel our construction offers decoupling and that, we think, correctly reflects the structure of the language.
Perhaps if we were to redo this, we would have taken the other approach.

\paragraph{\texttt{Global}} Our \texttt{Globals} are very simple.
They have a \texttt{name} and a BaseLanguage \texttt{Type}.
We added a smart reference so that \texttt{Rules} can easily use them.
The reference extended \texttt{Expression} from the BaseLanguage.
This extension is so that we could use it in the Java code of the Right-hand side.

\paragraph{\texttt{Rule}} Our \texttt{Rules} have three children: an \texttt{AttributeCollection}, a Right-hand side and a list of Conditions that make up the Left-hand side.
We created a component to describe the \texttt{Rule} editor for reuse, as we imagined that we would wrap this in other projections.

\paragraph{\texttt{RuleVariables}} The \texttt{Fact} of a \texttt{FactSelector} and the \texttt{FactProperty} of a \texttt{FieldConstraint} are bound to \linebreak\texttt{RuleVariables}.
\texttt{RuleVariables} are scoped to a \texttt{Rule}.
A \texttt{RuleVariable} has only a \texttt{name} and a \texttt{type}.
We also create a smart reference for it so that it can be used elsewhere within the rule.
Like the \texttt{Global}, it extends BaseLanguage's \texttt{Expression} to be available in the Java code of the Right-hand side.

\paragraph{Right-hand side} The right-hand side of the rule, for the most part, is Java code.
To implement this, we made the right-hand side of the rule a single \texttt{StatementList}.
A \texttt{StatementList} is a list of \texttt{Statements}, both from the BaseLanguage.
We chose these because they keep track of, amongst other things, scope.

There are some non-Java, Drools specific items that are available to the right-hand side.
Items that had to be useable within the right-hand side were \texttt{Globals}, \texttt{RuleVariables} and Drools specific functions.
These all extend \texttt{Expression} from the BaseLanguage.
This extension allows seamless integration with the Java code.

The Drools specific Methods that are required are \texttt{Insert}, \texttt{InsertLogical}, \texttt{Modify}, \texttt{Delete} and \texttt{Halt}.

\begin{figure}[h]
    \centering
    \fbox{\includegraphics[width=0.70\textwidth]{Sections/images/RHS.png}}
    \caption{RHS}
    \label{fig:RHS}
\end{figure}

Figure \ref{fig:RHS} shows some of the features discussed for the right-hand side, as shown in our default projection.
The right-hand side is the text shown between the \texttt{then} keyword and the \texttt{end} keyword.
The figure shows examples of plain Java code, such as assigning to the variable \texttt{program} and the \texttt{foreach} loop.
We can also see that Drools-Lite \texttt{RuleVariable} \texttt{\$s} is in the Java statements.
We have also highlighted the Drools specific methods placed in the code, in this case \texttt{\textbf{modify}} and \texttt{\textbf{insert}}   

\begin{figure}[h]
    \centering
    \fbox{\includegraphics[width=0.85\textwidth]{Sections/images/Rule.png}}
    \caption{Rule}
    \label{fig:Rule}
\end{figure}

\paragraph{\texttt{AttributeCollection}} the \texttt{AttributeCollection} is a container to hold all the attributes that apply to a rule.
Initially, we have only implemented the \texttt{NoLoopAttribute} and \texttt{SalienceAttribute}.
A developer activates these attributes using two intentions we added to the \texttt{Rule} Concept.
On line 2 in figure \ref{fig:Rule}, we can see an example of the \texttt{SalienceAttribute} added to a rule on line 2.
\footnote{In figure \ref{fig:Rule}, we added line numbers to this figure to make it easier to talk about.
The keywords \texttt{rule} on line 1, \texttt{when} on line 3, \texttt{then} on line 6, and \texttt{end} on line 8 have no meaning in the abstract syntax.
We added them to give the developer the same look and feel as a standard Drools file.}

\paragraph{Left-hand side} This is a collection of conditions.
There are four types of conditions.
\texttt{AndCondition}, \linebreak\texttt{OrCondition}, \texttt{NotCondition} and \texttt{ExistsCondition}.
\texttt{AndCondition}, \texttt{OrCondition}, and \texttt{NotCondition} have one or two children who are also conditions.
The \texttt{ExistsCondition} contains a \texttt{FactSelector}.

We added dynamic braces to only show braces around a Condition if it is a child of another Condition.
These braces add visual clarity without adding unnecessary clutter.
We also added some intentions to make it easy to switch between \texttt{ExistsCondition} and \texttt{NotCondition}.

On line 4 in figure \ref{fig:Rule}, the whole line represents an \texttt{ExistsCondition}.
Line 5 shows an \texttt{OrCondition} containing an \texttt{ExistsCondition} and a \texttt{NotCondition}.
The default editor, through an intention, can make the \linebreak\texttt{ExistsCondition} explicit with an \texttt{exists} keyword.
However, the standard practice with Drools developers is to make this implicit, so this is how we show it here.

\paragraph{\texttt{FactSelector}} This always has a reference to a \texttt{Fact}.
These \texttt{Facts} are \texttt{Program} in line 4 of figure \ref{fig:Rule} and \texttt{Student} and \texttt{Result} from line 5.

Optionally, the \texttt{FactSelector} can be bound to a variable.
In figure \ref{fig:Rule}, line 5, the \texttt{FactSelector} referencing the \texttt{Student} \texttt{Fact} is bound to the \texttt{\$s} \texttt{RuleVariable}.

The \texttt{FactSelector} also contains a list of constraints on \texttt{FactProperties}, all of which must return true for the \texttt{FactSelector} to return \texttt{true}.

\paragraph{Constraints} We have three types of constraints.
\texttt{AndConstraint} and \texttt{OrConstraint} contain other constraints.
The \texttt{FieldConstraints} places restrictions on \texttt{FactProperties}.

\paragraph{FieldConstraints} A \texttt{FieldConstraint} refers to a \texttt{FactProperty} and can be bound to a variable.
It also has a restriction applied to that \texttt{FactProperty}.
Using a substitute menu, we wrapped the \texttt{FactProperty} smart reference.
This substitution automatically creates the \texttt{FieldConstraint} from the \texttt{FactProperty} selection by the developer.

There are several types of restrictions and several types of values that they can restrict.

\paragraph{\texttt{RestrictionValues}} The \texttt{RestrictionValues} that a \texttt{FactProperty} can be compared with are as follows:
\begin{itemize}    
    \setlength\itemsep{0em}
    \item \texttt{LiteralRestrictions}: These are \texttt{Integer}, \texttt{Float}, \texttt{String}, \texttt{DateTime} and \texttt{Boolean}.
    \item \texttt{VariableRestrictions}: These can be \texttt{Globals}, \texttt{RuleVariables} referring to \texttt{Facts} from the \texttt{FactSelector}, or \texttt{RuleVariables} from other \texttt{FieldConstraints}.
    \item \texttt{ReturnValue}: This compares to anything expressed as an \texttt{Expression}, which includes referring to constants or values behind qualified identifiers.
\end{itemize}

In figure \ref{fig:Rule}, on line 4, we have the return values \texttt{Faculty.Law} and \texttt{Faculty.FNWI}.
On line 5, the literal values \texttt{7} and \texttt{8}.

\paragraph{Restrictions} A \texttt{SingleValueRestriction} compares a \texttt{FactProperty} against a value.
A \texttt{MultiRestriction} compares a \texttt{FactProperty} against multiple values, not necessarily using the same comparison for each value.
A \texttt{SetMembership} restriction checks if a \texttt{FactProperty} is a member or not a member of a group.

In figure \ref{fig:Rule} on line 4 a \texttt{SetMembership} restriction is shown with the \texttt{in ( Faculty.Law, Faculty.FNWI )} text.
Line 5 in the first \texttt{FactSelector} there is the \texttt{SingleValue} restriction \texttt{ avg >= 8}.
The second \texttt{FactSelector} shows a \texttt{MultiRestrictions} \texttt{grade <= 7 \&\& > 8}.

Thus, we have described the pertinent implementation details of the Drools-Lite language.

\subsection{Wireframes}

There are some potential projections we have conceived for which there is not sufficient time to implement.
We want Drools experts to assess these and thus would like them to appear as realistic as possible to the assessors.

Our solution to this conundrum is to develop these presentations in a wireframing tool.
The wireframe tool we chose was Axure\cite{Axure_ProductPage}.
We chose this because we had previous experience with the product.
Also, it is available to students for free.

We settled on two possible projectional programming aids: Truth table and circuit diagram.
We will discuss these in more detail in the results section.
