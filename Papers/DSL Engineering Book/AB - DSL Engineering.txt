DSL Engineering

1.10.2 JetBrains MPS
The Meta Programming System (MPS) is a projectional lan- jetbrains.com/mps
guage workbench, which means that no grammar and parser is
involved. Instead, editor gestures change the underlying AST
directly, which is projected in a way that looks like text. As
a consequence, MPS supports mixed notations (textual, symbolic, tabular, graphical) and a wide range of language composition features. MPS is open source under the Apache 2.0
license, and is developed by JetBrains. It is not as widely used
as Xtext, but supports many advanced features

Language designers define a DSL in three main parts: schema, editor(s) and generator(s). I agree that ideally a language should
be defined "meta model first", i.e. you first define a schema
(aka the meta model or AST), and then the concrete syntax
(editor or grammar), based on the schema: MPS does it this
way. However, I think it is also ok to start with the grammar, and have the meta model derived. This is the typical
workflow with Xtext, although it can do both. From the language user’s point of view, it does not make a big difference
in most cases.


 A Vision of Programming For me, this is the vision of programming I am working towards. The distinction between
modeling and programming vanishes. People can develop code
using a language directly suitable to the task at hand and aligned
with their role in the overall development project. They can
40 dslbook.org
also build their own languages or language extensions, if that
makes their work easier. Most of these languages will be relatively small, since they only address one aspect of a system,
and typically extend existing languages (Fig. 3.13 shows an example of extensions to C). They are not general-purpose: they
are DSLs.
Tools for this implementing this approach exist. Of course MPS is one of them, which is why
I focus a lot on MPS in this book.
Intentional’s Domain Workbench is
another one. Various Eclipse-based
solutions (with Xtext/ Xbase/Xtend at
the core) are getting there as well.
they can become even better, for example in the development
of debuggers or integration of graphical and textual languages,
but we are clearly getting there.



Parsing versus Projection
This part of the book is not about implementation techniques.
However, the decision of whether to build a DSL using a projectional editor instead of the more traditional parser-based approach can have some consequences for the design of the DSL.
So we have to provide some level of detail on the two at this
point

In the parser-based approach, a grammar specifies the sequence of tokens and words that make up a structurally valid
program. A parser is generated from this grammar. A parser is
a program that recognizes valid programs in their textual form
and creates an abstract syntax tree or graph. Analysis tools
or generators work with this abstract syntax tree. Users enter
programs using the concrete syntax (i.e. character sequences)
and programs are also stored in this way. Example tools in this
category include Spoofax and Xtext

Projectional editors (also known as structured editors) work
without grammars and parsers. A language is specified by
defining the abstract syntax tree, then defining projection rules
that render the concrete syntax of the language concepts defined by the abstract syntax. Editing actions directly modify
the abstract syntax tree. Projection rules then render a textual
(or other) representation of the program. Users read and write
programs through this projected notation. Programs are stored
as abstract syntax trees, usually as XML. As in parser-based
systems, backend tools operate on the abstract syntax tree

Projectional editing is well known from graphical editors;
virtually all of them use this approach13. However, they can
also be used for textual syntax. Example tools in this cat
egory include the Intentional Domain Workbench15 and Jet
Brains MPS.

MPS also provides annotations, allowing additional model data to be
"attached" to any model element, and
shown optionally.

MPS has a nice way of automatically
executing a quick fix for a constraint
violation. If the constraint detects an
inconsistency between viewpoints, the
quick fix can automatically correct the
problem. This also solves the whole
world problem neatly, since every
dependent fragment is "corrected" as
soon as it is opened in the editor

Projection In the projectional approach, the abstract syntax tree
is built directly by editor actions, and the concrete syntax
is rendered from the AST via projection rules. MPS is an
example of a tool that uses projectional editing

----------------------------------------
CHAP 1


You could argue that this whole business about DSLs is nothing new. It has long been possible to build custom languages
using parser generators such as lex/yacc, ANTLR or JavaCC.
And of course you would be right. 

However, I feel that language workbenches, which are tools
to efficiently create, integrate and use sets of DSLs in powerful
IDEs, make a qualitative difference. 

1.10.2 JetBrains MPS
The Meta Programming System (MPS) is a projectional lan- jetbrains.com/mps
guage workbench, which means that no grammar and parser is
involved. Instead, editor gestures change the underlying AST
directly, which is projected in a way that looks like text. As
a consequence, MPS supports mixed notations (textual, symbolic, tabular, graphical) and a wide range of language composition features. MPS is open source under the Apache 2.0
license, and is developed by JetBrains. It is not as widely used
as Xtext, but supports many advanced features.

n the Intentional Domain Work- intentsoft.com
bench (IDW). Like MPS, it uses the projectional approach to
editing. 

------------------------
CHAP 2

If you know about DSLs, you will know that there are two
main schools: internal and external DSLs.

A language, domain-specific or not, consist of the following
main ingredients. The concrete syntax defines the notation with
which users can express programs. It may be textual, graphical, tabular or a mix of these. The abstract syntax is a data
structure that can hold the semantically relevant information
expressed by a program. It is typically a tree or a graph. It
does not contain any details about the notation – for example,
in textual languages, it does not contain keywords, symbols or
whitespace. The static semantics of a language are the set of
constraints and/or type system rules to which programs have
to conform, in addition to being structurally correct (with regards to the concrete and abstract syntax). Execution semantics
refers to the meaning of a program once it is executed. It is
realized using the execution engine. If I use the term semantics
without any qualification, I refer to the execution semantics,
not the static semantics

Sometimes it is useful to distinguish between what I call
technical DSLs and application domain DSLs2
. The distinction 2 Sometimes also called business DSLs,
vertical DSLs or "fachliche DSLs" in
German.
is not always clear and not always necessary, but generally I
consider technical DSLs to be used by programmers and application domain DSLs to be used by non-programmers. This can
have significant consequences for the design of the DSL


The notion of abstraction is different, even though it also
characterizes the relationship between two artifacts (programs
or models). An artifact a1 is more abstract than an artifact a2 if
it leaves out some of the details of a2, while preserving those
characteristics of a2 that are important for whatever a1 is used
for – the purpose of a1 informs the the abstractions we use to
approximate a2 with a1.

The more specific the
tasks get, the more reason there is for specialized languages4

A Domain-Specific Language is simply a language
that is optimized for a given class of problems, called a domain. It is based on abstractions that are closely aligned with
the domain for which the language is built5
. Specialized lan-guages also come with a syntax suitable for expressing these
abstractions concisely. In many cases these are textual notations, but tables, symbols (as in mathematics) or graphics can
also be useful. Assuming the semantics of these abstractions is
well defined, this makes a good starting point for expressing
programs for a specialized domain effectively


Languages (and the programs you write with them), are the
cleanest form of abstraction – essentially, you add a notation to a conceptual model of the domain. You get rid of all
the unnecessary clutter that an API – or anything else embedded in or expressed with a general-purpose language –
requires. You can define a notation that expresses the abstractions concisely and makes interacting with programs
easy and efficient.
• DSLs sacrifice some of the flexibility to express any program (as in GPLs) for productivity and conciseness of relevant programs in a particular domain. In that sense, DSLs
are limited, or restricted. DSLs may be so restricted that
they only allow the creation of correct programs (correct-byconstruction).
• You can provide non-trivial static analyses and checks, and
an IDE that offers services such as code completion, syntax highlighting, error markers, refactoring and debugging.
This goes far beyond what can be done with the facilities
provided by general-purpose languages.


n. But beyond that, how are DSLs different from
GPLs, and what do they have in common?
The boundary isn’t as clear as it could be. Domain-specificity
is not black-and-white, but instead gradual: a language is more
or less domain specific. 

Programming languages have traditionally used textual concrete syntax, i.e. the program is represented as a stream of
characters. Modeling languages traditionally have used graphical notations. Of course there are textual domain-specific languages (and mostly failed graphical general-purpose languages),
but the use of textual syntax for domain-specific modeling has
only recently become more prominent. Programming languages
have traditionally stored programs in their textual, concrete
syntax form, and used scanners and parsers to transform this
character stream into an abstract syntax tree for further processing. Modeling languages have traditionally used editors
that directly manipulate the abstract syntax, and used projection to render the concrete syntax in the form of diagrams14


most software developers don’t want to model. They
want to program, but:

*at different levels of abstraction: some things may have to be described in detail, low level, algorithmically (a sorting algorithm); other aspects may be described in more high-level
terms (declarative UIs)
*from different viewpoints: separate aspects of the system should
be described with languages suitable to these aspects (data
structures, persitence mapping, process, UI)
* with different degrees of domain-specificity: some aspects of systems
are generic enough to be described with reusable, generic
languages (components, database mapping). Other aspects
require their own dedicated, maybe even project-specific DSLs
(pension calculation rules).
with suitable notations, so all stakeholders can contribute directly
to "their" aspects of the overall system (a tabular notation for
testing pension rules)
* with suitable degrees of expressiveness: aspects may be described
imperatively, with functions, or other Turing complete formalisms (a routing algorithm), and other aspects may be
described in a declarative way (UI structures)
always integrated and tool processable, so all aspects directly lead
to executable code through a number of transformations or
other means of execution.



Martin Fowler21. He defines language workbenches as tools

Users can freely define languages that are fully integrated with
each other. This is the central idea for language workbenches,
but also for modular languages, since you can easily argue
that each language module is what Martin Fowler calls a
language. "Full integration" can refer to referencing as well
as embedding, and includes type systems and semantics.

• The primary source of information is a persistent abstract representation and language users manipulate a DSL through a projectional editor. This implies that projectional editing must
be used22. I don’t agree. Storing programs in their abstract
representation and then using projection to arrive at an editable representation is very useful, and maybe even the best
approach to achieve modular languages23. However, in the
end I don’t think this is important, as long as languages are
modular. If this is possible with a different approach, such
as scannerless parsers24, that is fine with me.

Language designers define a DSL in three main parts: schema, editor(s) and generator(s). I agree that ideally a language should
be defined "meta model first", i.e. you first define a schema
(aka the meta model or AST), and then the concrete syntax
(editor or grammar), based on the schema: MPS does it this
way. However, I think it is also ok to start with the grammar, and have the meta model derived. This is the typical
workflow with Xtext, although it can do both. From the language user’s point of view, it does not make a big difference
in most cases.

A language workbench can persist incomplete or contradictory information. I agree. This is trivial if the models are stored in a
concrete textual syntax, but it is not so trivial if a persistent
representation based on the abstract syntax is used

Let me add two additional requirements. For all the languages
built with the workbench, tool support must be available: syntax highlighting, code completion, any number of static analyses (including type checking in the case of a statically typed
language) and ideally also a debugger25. A final requirement
is that I want to be able to program complete systems within
the language workbench. Since in most interesting systems you
will still write parts in a GPL, GPLs must also be available in
the environment based on the same language definition/editing/processing infrastructure. Depending on the target domains, this language could be Java, Scala or C#, but it could
also be C/C++ for the embedded community. Starting with an
existing general-purpose language also makes the adoption of
the approach simpler: incremental language extensions can be
developed as the need arises.


Concrete Syntax By default, I expect the concrete syntax of
DSLs to be textual. Decades of experience show that textual
syntax, together with good tool support, is adequate for large
and complex software systems26. This becomes even more true
if you consider that programmers will have to write less code
in a DSL – compared to expressing the same functionality in a
GPL – because the abstractions available in the languages will
be much more closely aligned with the domain. And programmers can always define an additional language module that fits
a domain.
Using text as the default does not mean that it should stop
there. There are worthwhile additions. For example, symbolic
(as in mathematical) notations and tables should be supported.
Finally, graphical editing is useful for certain cases. Examples
include data structure relationships, state machine diagrams or
data flow systems. The textual and graphical notations must be
integrated, though: for example, you will want to embed the
expression language module into the state machine diagram to
be able to express guard conditions.
The need to see graphical notations to gain an overview over
complex structures does not necessarily mean that the program
has to be edited in a graphical form: custom visualizations are
important as well. Visualizations are graphical representations
of some interesting aspect of the program that is read-only, automatically laid out and supports drill-down back to the program (you can double-click on, say, a state in the diagram, and
the text editor selects that particular state in the program text).


Once you’ve got a language and its execution engine for a particular aspect of your development task, work becomes much
more efficient, simply because you don’t have to do the grunt
work manually29. This is the most obviously useful if you can
replace a lot of GPL code with a few lines of DSL code. There
are many studies that show that the mere amount of code one
has to write (and read!) introduces complexity, independent of
what the code expresses, and how. The ability to reduce that
amount while retaining the same semantic content is a huge
advantage.
You could argue that a good library or framework will do
the job as well. True, libraries, frameworks and DSLs all encapsulate knowledge and functionality, making it easily reusable.
However, DSLs provide a number of additional benefits, such
as a suitable syntax, static error checking or static optimizations
and meaningful IDE support.


*** correct-byconstruction
GOT TO: 2.5.4 Data longevity pg 41



