AB - Implementing Modular Domain Specific Languages and Analyses

 A DSL can often be decomposed into several conceptually distinct sub-languages
 
 Obvious analyses
relevant for such expressions include checking whether these
expressions cover the whole spectrum of the input values
(completeness) and if there are expressions that can evaluate to true at the same time (consistency). By implementing
these analyses for a shared language module, the analyses
are made available to all the DSLs that reuse this module.

Language
extension adds additional constructs to an existing language.
Language restriction removes some concepts from an existing language. Language embedding joins two previously unrelated languages. In all three cases, the original language(s)
are not modified invasively, retaining modularity

2.1 Language Workbenches and MPS
Language workbenches are tools that make language and
IDE development, modularization and composition feasible.
There are two fundamentally different approaches for language implementation as realized by language workbenches.
Parser-based systems make use of grammars that specify the
textual structure of legal programs expressed in some language l. A parser is generated from that grammar which
transforms programs expressed in l into a data structure
that contains the information expressed by a program, but
gets rid of the textual concrete syntax. This data structure
is called an abstract syntax tree (AST). All downstream processing (analyses, transformation) is performed on the AST.
Projectional systems work without grammars and parsers:
as a user edits a program, the AST is modified directly and
the program’s textual (or other) syntax is merely a projection. While parser-based systems support language modularization and composition to some degree, it is easy to do
and well supported in projectional systems. JetBrains MPS
(http://jetbrains.com/mps) is an example of a projectional
language workbench. 

Decision Tables
Decision tables exploit JetBrains MPS’ projectional editor in
order to represent two-level nested if statements as a table.

As a consequence of the projectional editor, very few concrete syntax concerns have to be considered when modularizing and composing languages. This means that that language development in MPS closely resembles object-oriented
programming. Essentially all idioms and patterns known
from mainstream OO languages like Java can be used in
language development (details can be found in [9]). So in
the remainder of this section we will just discuss the abstract
syntax.


*** should I be using a solver for completeness

[4]	R. Janicki, D. L. Parnas, and J. Zucker. Tabular representations in relational documents, pages 184–196. Springer-Verlag New York, Inc., 1997.

[7]	M. Mernik, J. Heering, and A. M. Sloane. When and how to develop domain-specific languages. ACM Computing Surveys, 37(4):316–344, 2005.

