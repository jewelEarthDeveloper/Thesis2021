todo
AB - Notable design patterns for domain-specific languages 
e.
Speci®cally, DSLs are by de®nition part of a larger system and often implemented for a narrow usage domain. 

n.
The resources available for designing and implementing them are therefore constrained to a small percentage of those available for the system they belong to, and diffcult to amortise over a large user base.



A DSL is a programming language tailored speci®cally to an application domain: rather than being for a general purpose, it captures precisely the domain's semantics.

DSLs allow the concise description of an application's logic reducing the semantic distance between the problem and the program (Bell et al., 1994;
Spinellis and Guruprasad, 1997)


 As a design choice for implementing software systems, DSLs present a number of distinct advantages over a ``hard-coded'' program logic:
Concrete expression of domain knowledge.
Domainspeci®c functionality is not coded into the system or stored in an arcane ®le format; it is captured in a concrete human-readable form.
Programs expressed in the DSL can be scrutinised, split, combined, shared, published, put under release control, printed, commented, and even be automatically generated by other applications.
Direct involvement of the domain expert.
The DSL expression style can often be designed so as to match the format typically used by the domain expert.
This results in keeping the experts in a very tight software lifecycle loop where they can directly specify, implement, verify, and validate, without the need of coding intermediaries.


Expressiveness.
Executable speci®cation languages taking a Swiss army knife approach towards the problem of speci®cation offer facilities for specifying all types of systems, but often at a cost of clearness of expression.

Reliability.
As described in the previous paragraph, the limited scope of a DSL often allows a source-tosource transformation type of implementation.
The small scale of the required implementation effort often results in a translator whose correctness can be trivially verified.

the following potential shortcomings of this approach:
Tool support limitations.
CASE and integrated software development tools offer only limited support for integrating DSLs into the development process.
Ad hoc solutions are often required to smoothly integrate DSL
code with existing revision control systems, compilers, editors, source browsers, and debuggers 

Training costs.
In contrast to established speci®cation languages such as Z (Potter et al., 1991) system implementers and maintainers will by de®nition have no prior exposure to the DSL being used 
Design experience.
DSL-based system architectures are not widely adopted within the software industry.
As a result, there is an evident lack of design experience, prescriptive guidelines, mentors, design patterns, and supporting scienti®c literature 

Software process integration.
The use of DSLs is not yet an integral part of established software processes.
Therefore, the software process being used has to be modi®ed in order to take into account the design, implementation, integration, debugging, and maintenance of the adopted DSLs.

is this something for Felienne? - the educational subsets of Pascal used for a stepwise introduction to the language (Savitch, 1995)


Throughout our literature research for drafting this work we were impressed by the multitude of DSL designs, implementation strategies, and resulting systems, and the scarcity of supporting design frameworks and methodologies.






Faith, R.E., Nyland, L.S., Prins, J.F., 1997.
KHEPERA: A System for Rapid Implementation of Domain Speci®c Languages.
In: Ramming (1997).





Landin, P.J., 1966.
The next 700 programming languages.
Commun.
ACM 9 (3), 157±166.


Simonyi, C., 1995.
The Death of Computer Languages and the Birth of Intentional Programming, Technical Report MSR-TR-95-52, Microsoft Corporation, Redmond, WA, USA, September.
Available 
