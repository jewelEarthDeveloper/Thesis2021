AB - Language Composition Untangled 
Domain-specific languages (DSLs) are a prominent candidate for bridging the gap between domain concepts and software developers.

To implement a DSL, a language developer can, for example, write a parser and interpreter, apply an attribute grammar system [8, 30], use a language workbench [6, 17], write a compiler plug-in for an extensible compiler [8, 19], or provide a library for domain primitives using regular functions [15], macros [28, 27], or sugar libraries [11].

"language extension, language restriction, language unification, self-extension, and extension composition"

A language designer composes a base language with a language extension.
A language extension is itself a language fragment, which typically makes little sense when regarded independent of the base language.
This dependency of the language extension on the base language is the main characteristic of this form of language composition.


Definition 1.
A language-development system supports language extension of a base language if the implementation of the base language can be reused unchanged to implement a language extension.

Language restriction.
Especially in education, it sometimes makes sense to restrict an existing programming language. 



Language unification Accordingly, we want to compose languages in an unbiased manner.
Furthermore, the language composition should be deep and bidirectional, that is, program fragments from either language should be able to interact with program fragments from the other language.
A language designer composes two independent languages by unification.
Like in mathematical unification, language unification requires that parts of the languages are equalized.
For example, deep integration often requires sharing of primitive data types such as numbers or strings 
Definition 2.
A language-development system supports language unification of two languages if the implementation of both languages can be reused unchanged by adding glue code only.


Self-extension  Traditionally, this form of language composition is called language embedding: A domain-specific language is embedded into a host language by providing a host-language program that encapsulates the domain-specific concepts and functionality [15

To compose a host language with an embedded language, a language implementer develops, in the host language itself, a program which defines the embedded language 
Definition 3.
A language supports self-extension if the language can be extended by programs of the language itself while reusing the language’s implementation unchanged.


Extension composition 
The projectional language workbench MPS [33] rejects parsing and applies intentional programming instead.
Essentially, MPS maintains a central program representation, which can be thought of as an AST, and displays projections of the AST to the programmer.
To edit a program, a programmer sends edit directives to MPS, which applies the edits to the central AST and updates the projection.
This way MPS provides IDE support and creates a user experience close to usual programming environments.
Furthermore, MPS supports extensibility: The central program representation can be extended by new concepts, which can integrate into existing projections, validations, and code generation.
As in the other systems, once defined, the behavior of an extension is fixed [32]
 





[6]	S.
Efftinge and M.
Voelter. oAW xText: A framework for textual DSLs.
In Workshop on Modeling Symposium at Eclipse Summit, 2006.





[13]	J.
Heering, P.
R.
H.
Hendriks, P.
Klint, and J.
Rekers.
The syntax definition formalism SDF – reference manual.
SIGPLAN Notices, 24(11):43–75, 1989.

[14]	C.
Hofer, K.
Ostermann, T.
Rendel, and A.
Moors.
Polymorphic embedding of DSLs.
In Proceedings of Conference on Generative Programming and Component Engineering (GPCE), pages 137–148.
ACM, 2008.

[15]	P.
Hudak.
Modular domain specific languages and tools.
In Proceedings of International Conference on Software Reuse (ICSR), pages 134–142.
IEEE, 1998.


[17]	L.
C.
L.
Kats and E.
Visser.
The Spoofax language workbench: Rules for declarative specification of languages and IDEs.
In Proceedings of Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), pages 444–463.
ACM, 2010.


