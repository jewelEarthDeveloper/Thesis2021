AB - Product Line Engineering using Domain-Specific Languages

The goal of product line engineering (PLE) is to efficiently
manage a range of products by factoring out commonalities
such that definitions of products can be reduced to a specification of their variable aspects

being exposed to implementation details.
DSLs are a good fit when instances of concepts need to be
created, when relationships between these instances must be
established, or when algorithmic behavior has to be described,
e.g. in business rules, calculations, or events. Examples of
the application of DSLs include calculating the VAT and
other taxes in an invoicing product line, specifying families
of pension contracts, and defining communication protocols
in embedded systems.

n embedded systems.
In general, a domain-specific language (DSL) is a software
language specialized for a particular problem domain. DSLs
can use graphical, textual or tabular concrete syntax, or any
combination thereof. Like programming languages, DSLs can
either be compiled — typically through code generation to
a programming language — or interpreted by an interpreter
running on the target environment.

A DSL’s concrete and abstract syntax are tailored closely
to the domain at hand. Using DSLs only requires knowledge
about the problem domain, not about the solution domain.
This improves productivity, quality and maintainability. Productivity is improved because a higher level notation is provided, avoiding dealing with implementation details. Quality
is improved because transformations or interpreters execute
the programs consistently. Maintainability is improved because
changes to the program can be done on the level of the DSL
program, or by changing the generator or interpreter.

A note on terminology: we use the terms DSL program,
DSL code and model interchangably. Strictly speaking, the
DSL code is a textual representation of a model, but this
distinction is not relevant in this paper. While we focus
primarily on textual DSLs in this paper, the discussion is
equally valid for DSLs using other notations, as long as the
underlying expressivity is not reduced, as for example in
purely tabular notations. However, expression-like models can
best be expressed using a textual notation.
Supplying convenient editors and other tools along with
the DSL increases the usability of the language significantly.
The term language workbench has been introduced by Martin
Fowler in 2004 [11], referring to tools that support the efficient definition, composition and use of DSLs. Open Source
examples include Eclipse Xtext (http://eclipse.org/xtext),
Spoofax (http://strategoxt.org/Spoofax) and JetBrains MPS
(http://www.jetbrains.com/mps/).


MPS’ capability to combine independently developed languages makes the composition of an
overall product configuration from program/model fragments
expressed in various languages almost trivial. Language composition in MPS and the annotation mechanism is explained
in detail in [20]

C. Architecture DSLs
Many product lines are built on a common software architecture, while the application functionality varies from product
to product. Architecture DSLs [21], [12] can be used very
effectively in these cases. An architecture DSL is a DSL,
in which the abstractions of the language correspond to the
architectural concepts of the execution platform. They are
defined by architects, and used by developers as they develop applications. When developing products in challenging
environments such as distributed real-time embedded systems,
architecture DSLs can provide the benefit of simulation and
automatic optimization as described by Balasubramanian and
Schmidt in [3].


 Core Assets designate reusable artifacts that are used
in more than one product. As a consequence of their
strategic relevance, they are usually high quality and
maintained over time. Some of the core assets might have
variation points.
• A Variation Point is a well-defined location in a core asset
where products differ from one another.
• Kind of Variability classifies the degrees of freedom one
has when binding the variation point. This ranges from
setting a simple Boolean flag over specifying a database
URL to a DSL program to a Java class hooked into a
platform framework.
• Binding Time denotes the point in time when the decision
is made as to which alternative should be used for a
variation point. Typical binding times include source time
(changes to the source code are required), load time
(bound when the system starts up) and runtime (the
decision is made while the program is running).
• The Platform are those core assets that actually form a
part of the running system. Examples include libraries,
frameworks or middleware.
• Production Tools are core assets that are not part of
the platform, but are used during the possibly automated
development of products.
• Domain Engineering refers to activities in which the core
assets are created. An important part of domain engineering is domain analysis, during which a fundamental
understanding of the domain and its commonalities and
variability is established.
• Application Engineering is the phase in which the domain
engineering artifacts are used to create products. Unless
variation points use runtime binding, they are bound
during this phase.
• The Problem Space refers to the application domain
in which the product line resides. The concepts found
in the problem space are typically meaningful to nonprogrammers as well.
• The Solution Space refers to the technical space that is
used to implement the products. In case of software product line engineering, this space is software development.
The platform lives in the solution space. The production
tools create or adapt artifacts in the solution space based
on a specification of a product in the problem space.

e. Language embedding is not yet mainstream.
It supported for example by Spoofax [14] and MPS [20].

C. Problem Space and Solution Space
DSLs can represent any domain. They can be technical,
inspired by a library, framework or middleware, expected
to be used by programmers and architects. DSLs can also
cover application domains, inspired by the application logic
for which the application is built. In this case they are expected
to be used by application domain experts. In the case of
application DSLs, the DSL resides in the problem space.
For execution they are mapped to the solution space by the
production tools. Technical DSL can, however, also be part of
the solution space. In this case, DSL programs are possibly
created by the mapping of an application domain DSL to the
solution space. This is an example of cascading [18], [7]: one
DSL is executed by mapping it to another DSL. It is also
possible that technical DSLs are used by developers as an
annotation for the application domain DSLs, controlling the
mapping to the solution space or configuring some technical
aspect of the solution directly [18]


DSLs can be executed in two ways. Transformation maps a
DSL program to another formalism for which an execution
infrastructure already exists. If this formalism is another
DSL, we speak of model-to-model transformation, or simply
transformation. If the target is a programming language, we
speak of code generation. 












[18]	M. Voelter. Best practices for dsls and model-driven development. JOT, 2009.
[19]	M. Voelter and I. Groher. Handling variability in model transformations and generators. In Proceedings of the 7th OOPSLA Workshop on Domain-Specific Modeling (DSM’07), Computer Science and Information System Reports, 2007.

