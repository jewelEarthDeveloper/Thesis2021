todo
AB - The Pragmatics of Model-Driven Development 

Models help us understand a complex problem and its potential solutions through abstraction.
Therefore, it seems obvious that software systems, which are often among the most complex engineering systems, can benefit greatly from using models and modeling techniques.
However, for historical reasons, models in software engineering are infrequent and, even when used, they often play a secondary role 

Software engineering is in the unfortunate position of being a new and relatively immature branch of engineering of which much is expected.
Seduced by the relative ease of writing code—there is no metal to bend or heavy material to move—and compelled by relentless market pressures, software users and developers are demanding systems whose complexities often exceed our abilities to construct them.


MDD’s defining characteristic is that software development’s primary focus and products are models rather than computer programs.

The major advantage of this is that we express models using concepts that are much less bound to the underlying implementation technology and are much closer to the problem domain relative to most popular programming languages.
This makes the models easier to specify, understand, and maintain; in some cases, it might even be possible for domain experts rather than computing technology specialists to produce systems.
It also makes models less sensitive to the chosen computing technology and to evolutionary changes to that technology (the concept of platform-independent models is often closely connected to MDD).


Of course, if models end up merely as documentation, they are of limited value, because documentation all too easily diverges from reality.
Consequently, a key premise behind MDD
is that programs are automatically generated from their corresponding models.

 This is why solutions based on so-called round-trip engineering, which automatically converts code back into model form, are much more useful.
One drawback here, though, is that an automated conversion from code to model usually can’t perform the kind of abstraction that a human can.
Therefore, we can attain MDD’s full benefits only when we fully exploit its potential for automation.
This includes ■ Automatically generating complete programs from models (as opposed to just code skeletons and fragments)
■ Automatically verifying models on a computer (for example, by executing them)


The techniques and tools for doing this successfully have now reached a degree of maturity where this is practical even in large-scale industrial applications.
Modern code generators and related technologies can produce code whose efficiency is comparable to (and sometimes better than) hand-crafted code.
Even more importantly, we can seamlessly integrate such code generators into existing software production environments and processes.
This is critical because it minimizes the disruption that occurs when MDD is deployed.


To be useful and effective, an engineering model must possess, to a sufficient degree, the following five key characteristics.
The most important is abstraction.
The second key characteristic is understandability The third key characteristic of useful models is accuracy.
Fourth is predictiveness.
Finally, a model must be inexpensive 
(David Harel compares models that can’t be executed to cars without engines).


