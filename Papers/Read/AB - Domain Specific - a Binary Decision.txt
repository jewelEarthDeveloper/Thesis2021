AB - Domain Specific - a Binary Decision 

In many methodologies that proclaim to use domain specific modeling, there is still the need to write code in general purpose programming languages to express certain aspects of the system.

In this paper we argue that it is useful to be able to mix domain-specific and general purpose aspects in a cojoint environment.
Specifically DSLs and GPLs can be seen as collaborating languages in one tool called language workbench.

programming and modeling should not be considered different. 

To be able to discuss about the domain specificity of something, we should first define what a domain is.
We have taken the following definitions:

• Domain (software engineering): a field of study that defines a set of common requirements, terminology, and functionality for any software program constructed to solve a problem in that field 
• Domain engineering: the reusing of domain knowledge in the production of new software 
• Domain knowledge: a specific expert knowledge valid for a pre-selected area of activity, such as surgery 
As programmers we often distinguish between business domains and technical domains, with the rough distinction being that business domains are what non-programmers care about and technical domains are what programmers care about.
However, if you consider electrical engineers or scientists as nonprogrammers, then the distinction blurs: in embedded systems for example, state machines and block diagrams are what these "domain experts" use for designing their systems, although developers probably would not consider these languages to be business-domain specific 

So let us consider a domain to be anything for which a specific set of abstractions and notations is advantageous when describing structure or behavior in that domain.
It can be wide, narrow, deep, shallow, business-oriented or technical. 

Domains can also be hierarchical in that one domain is a specialized (or: narrower) variant of another one.
For example, robot control is specialized compared to embedded systems in general.
The abstractions from embedded systems are also useful in robot control, but there are more specialized abstractions that make sense in addition.
This is an important observation, because this kind of relationship between domains should be represented by the DSLs for domains. 

Historically there is (still) a somewhat "clear" distinction between modeling and programming.
Modeling is often associated with graphical languages, domain specific (Entity-Relational for DBs) or general purpose (e.g. UML).
A code generator then produces most of the artifacts automatically, yet the developer often has also to manually implement certain artifacts.
Sometimes he even has to extend or complete the generated code, e.g. because the modeling language does not support the concepts the developer needs.

With the advent of textual DSLs [11] and the associated IDE support via textual language workbenches [10], the modeling community is increasingly becoming aware of the benefits of textual modeling.
However the gap between modeling and programming still exists in practice, especially regarding the tools used for the two activities. 

We do not think that it is really necessary (or even useful) to distinguish between modeling and programming in the end.
Essentially modeling and programming should be the same.
One could even come up with the provoking statement that "we don't want to model; we want to program"…
• at various levels of abstraction • from different viewpoints • all of these integrated • with different degrees of domain specificity • with suitable notations • and with suitable expressiveness • and always precise, tool processable and with IDE support 

4. MODULAR LANGUAGES
Modular languages are languages that can be incrementally extended.
They integrate with other modules in the following ways:
• referencing: language concepts from module A can refer to language concepts from module B.
Languages come with their own notations and the programs written in these languages are stored in their own partitions/models/diagrams.
However, references to program elements expressed with other languages are possible and tool supported. 

• cascading: concepts from module A are translated into concepts from module B as a means of implementing A's concepts.
This way, more abstract languages can be cascaded on top of more general languages, supporting incremental addition of domain specific abstractions.
An interesting base case is where things are cascaded on top of existing programming languages -- this is conceptually similar to what's today typically called code generation. 

• extension: module B extends module A in the sense that it provides additional language concepts.
B is a superset of A.

• embedding: concepts from module A can be embedded in concepts from module B.
Notations defined in A and B are reused, even if the language modules are embedded.
To make this feasible, it must be possible to extend the languages as well, since additional concepts that connect the embedded concepts to the surrounding modules are required.

• annotation: language A contributes additional properties to existing concepts of a language B without invasively modifying B.
This is similar to introductions in AOP.

• cross-cutting by translation: this last kind of integration is a little bit different in that it does not add any language concepts.
Instead a module A (transparently) changes the translation of concepts defined in a language B without invasively changing B. 

JetBrains’ Meta Programming System is an open source projectional language workbench [4].
This means that users don't edit ASCII text that is then parsed, but each editing operation directly changes the tree structure of the underlying program.
Since we deal with a projectional editor there is no parser involved and different projections (textual, graphical, and tabular) are possible.
Lastly the generator is defined to emit text (for a low-level language) or it transforms higher-level code into code expressed in lower level languages..

Editing the tree as opposed to “real text” needs some getting used to.
Without specific adaptations, every program element has to be selected from a drop-down list and "instantiated".
However, MPS provides editor customizations to enable editing that resembles modern IDEs that use automatically expanding code templates. 

We now briefly illustrate how a language is defined in MPS.
A more extensive description can be found in [5].
MPS, like other language workbenches, comes with a set of DSLs for language definition, a separate DSL for each language aspect.
Language aspects include structure, editor, type system, generator as well as support for features such as quick fixes or refactorings. 

Defining a new language starts with the language structure (aka meta model).
This is very much like object oriented programming since language elements are represented as concepts that have properties, children and references to other concepts.
The second step is the editor for the language concepts.
An editor defines how the syntax for the concepts should look like - it constitutes the projection rules.
Figure 1 is an example.
Next is the definition of the type system.
For example, the type property of a LocalVariableDeclaration must be compatible with the type of its init expression.
For the type system definition as well as further customization the reader is referred to [5].
We already alluded to the relationship between object oriented programming and language definition in MPS.
This analogy also holds for language extension and specialization.
Concepts can extend other concepts, and subconcepts can be used polymorphically.
Languages also define translation rules to lower-level languages or to text.
MPS includes an incremental translation engine that reduces program code as long as translation rules are available for the program elements.
At the end, text generators output regular program text that can be fed into a compiler 
Like JetBrains, Intentional also uses a projectional approach.
It is similar in concept, but quite different in detail.
The layouting and rendering engine it more powerful than the one used by MPS.
The authors have seen examples where for example circuit diagrams or fraction bars are used as part of (otherwise normal) C programs.
Other examples include insurance mathematics mixed with "normal" programs.
So the ability to mix and match notations seems to be quite sophisticated. 


The discussion about "domain specific or not" becomes irrelevant, we'll just talk about suitable and not-so-suitable abstractions and notations.
If abstractions are not suitable, we can build and integrate additional language abstractions.
We can build our own, or use languages from a library.
Finally domain experts can be integrated into the process where it makes sense. 