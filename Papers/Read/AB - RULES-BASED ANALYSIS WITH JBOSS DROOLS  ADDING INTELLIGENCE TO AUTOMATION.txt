todo
AB - RULES-BASED ANALYSIS WITH JBOSS DROOLS  ADDING INTELLIGENCE TO AUTOMATION 

Rules engines are less-known as software technology than the traditional procedural, object-oriented, scripting or dynamic development languages.
T


Some example uses of enriching automated processes with analysis and decision logic are:
• What to do next? Complex and/or dynamic routing or filtering logic based on previously obtained information • Is what we did OK? automated analysis or validation of results obtained in previous steps • Just wake me up when you need me.
Intelligent monitoring systems, integrated in the same platform to automate basic control processes and business processes • Wait a moment, how did we get in this mess?
Software technology evolution analysis results to obtain a final diagnosis on a problem situation • Oops, how can we get this resolved? Automated advises for corrective actions in case of problems • Don't bother me any more for this.
Automating simple recurring decision processes 
Automated diagnosis or decision management can be decomposed in the following stages :
• Autonomous monitoring or discovery Continuously track some important performance indicators and generate an alarm when a value becomes suspect.
• Context-sensitive analysis of raised alarms Typically involves looking at many different datasets and measurements.
Uses thresholding, trending etc. to identify exceptions (e.g. taking your fever)
• Consolidation of obtained information and analysis results towards a diagnosis or decision (e.g. “you've got a simple flue”).
This may optionally include advises for problem resolution or repair.

RULE ENGINES
To cater for the above needs, the software system must be able to handle large volumes of data and to apply complex reasoning logic on it.
An easy-to-understand reasoning approach uses conditional actions, also known as “if-then” logic.
Such constructs are frequently used in traditional programming, but for representing complex context-dependent logic they quickly become a nightmare to understand or maintain since :
• it quickly becomes tricky to correctly represent all combinatorial possibilities of the conditions with nested if-then-else statements • the logic is spread out across different parts of the code base • the result becomes more and more fragile with each incremental adaptation Rule engines are specialized software systems for applying conditional actions (if/then rules) on data.
The use of a rule engine brings following benefits :
• business logic, expressed as rules, can be externalized from the application code.
The business logic can then be maintained in a centralized way with dedicated tools.
• rules can be defined in human-readable form in text files, spreadsheets etc.
• rules are often defined in a declarative way.
Starting from facts that you know are true, the desired outcome or action is defined.
• rule engines are optimized to evaluate large rule bases, find matching conditions and trigger the corresponding rules.


The term “rule engine” is used in different ways.
The ones which interest us are also known as “production rule systems”.
The central part of such a system is an inference engine that is able to match rules against facts or data to infer conclusions which result in new facts or in actions.
Through optimized matching algorithms such engines are able to scale to high volumes of rules and facts.

Drools[1] is the leading open-source rules engine written in Java.
It was started in 2001 and became a prominent Java rules engine with its 2.0 release.
In 2005
the Drools project became part of the JBoss group and since then Drools also became known as JBoss Rules.
In 2006 JBoss was acquired by Red Hat 

Drools Engine The core of the Drools suite is an advanced Inference Engine using an improved Rete algorithm[2] for pattern matching, adapted for object oriented systems, and for Java in particular.
Rules are stored in the production memory, while facts are maintained in the working memory.

The production memory remains unchanged during an analysis session, i.e. no rules are added or removed or changed.
The contents of the working memory on the other hand can change.
Facts may be modified, removed or added, by executing rules or from external sources.
After a change in the working memory, the inference engine is triggered and it determines which rules become “true” for the given facts.
If there are multiple selected rules, their execution order will be managed via the Agenda, using a conflict resolution strategy 
When a selected rule has been executed, and one or more changes were done in the working memory, the inference engine goes to work again, adapting the agenda and executing the rule that has now reached the highest priority.
This iterative process continues until the agenda is empty.
Then the analysis session terminates and results can be queried from the working memory or through the usage of global variables.

[2]	Charles Forgy, "On the efficient implementation of production systems." Ph.D.
Thesis, Carnegie-Mellon University, 1979. 
[