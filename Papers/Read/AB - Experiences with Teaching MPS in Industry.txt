AB - Experiences with Teaching MPS in Industry 
Once domain models are expressed in semantically rich languages, then advanced analyses (e.g. consistency checks), higher automation (e.g. generation of other artifacts) and support for authoring models (e.g. meaningful auto-completion and smart editor actions) become possibl 

Language development requires a good understanding of concepts related to programming languages such as abstract syntax, concrete syntax, type systems, or generators.
Furthermore, classical topics like processes, quality assurance, maintenance and evolution must be applied also when languages are developed.


JetBrains is a company which provides the MPS technology – the main know-how is about developing the language engineering technology (meta-meta level). itemis is a company specialized in providing solutions, which use model based development – the main focus is on building languages and tooling for customers (meta-level).
Siemens is a large company active in many business domains and a typical targeted end-user of language engineering technologies (modellevel). 


Jetbrains’ Meta-Programming System is a language workbench which offers comprehensive support for all concerns of the development of DSLs and associated tooling.
In MPS, a language implementation consists of several language aspects.
MPS ships with a dedicated DSL for implementing each language aspect.
For reasons of brevity, we will not describe any of the aspect-specific languages in detail; we refer the reader to [3] and [4].

A.
The Structure Definition Aspect The structure aspect uses a declarative DSL to describe the AST of a language.
Each AST element is called a concept, and concepts can have children (that constitute the tree), references (cross-references through the tree), and properties (primitive-typed values).
In addition, a concept can extend another concept and implement several concept interfaces.
Like any framework, MPS provides several interfaces and base concepts which have special meaning and need to be known by language developers.
In order to build domain specific tooling, 1 https://confluence.jetbrains.com/display/MPSD20171/Fast+Track+to+MPS

https://www.jetbrains.com/mps/
language developers also need to read or modify the models.
To this end, MPS supports a rich API wrapped in the ”smodel” language 

B.
The Editor Definition Aspect.
MPS features at its core a projectional editor to display the models.
Projectional editors do not use parsers; instead, they render, or project, a program’s AST in a notation defined by the language developer.
MPS’ editor aspect defines this notation – it is made up of cells arranged in a hierarchy.
Language engineers can extend the editors and define their specific notations appropriate for the DSLs they build – e.g. tabular, diagrams, mathematics or trees.
Each of these notations is supported by a special DSL which lower the complexity of writing editors.

MPS supports the definition of several editors for a single concept that can be switched at runtime.
In addition, editor definitions can contain logic to project the same concepts in different ways (i.e. possibly using different notations), depending on context or user preference 
Being a projectional editor, MPS does not feel like text editors when users edit their models.
In order to increase the fluency of models creation and modification, MPS allows advanced customization of editors actions – e.g. what happens when the user presses ”backspace” in a certain editor cell, or how are linear sequences of lexical items transformed into models.

C.
The Type System Definition Aspect.
Type systems are specified using declarative typing equations; MPS processes them using a solver.
Various different kinds of equations are supported, the most important one is the type inference rule.
It acts as type inference, but also acts as a type checker if several equations require different types for the same AST nodes.

MPS also supports checking of context sensitive constraints with the help of checking rules; these are essentially ifstatements that check some property of the AST and report errors if invalid code is detected.
The analyses performed by checking rules can be arbitrarily complex.
Once an error is identified, language engineers have also the possibility to implement support for the language users to fix these errors via IDE automation – known as quick-fixes.

D.	The Constraints Definition Aspect.
Typing and checking rules inspect an AST and report errors if invalid structures or types are found.
In contrast, scopes and constraints prevent the user of a language from constructing invalid models up front.
Remember that in a projectional editor, users can only enter code that is proposed through the code completion menu.
The structure of a language determines the concept that can be used in a child or reference link.
Scopes and constraints further constrain the valid nodes, beyond the concept.
This is the main means of MPS to support building of only meaningful models in a pure constructive manner.


E.	The Generators Definition Aspects.
MPS supports two kinds of transformations.
Like many other tools it support text generation from an AST.
The DSL to achieve this essentially lets developers add text to a buffer and helps with indentation.
However, most of MPS’ transformation work is done by mapping one AST to another one (model-tomodel); only at the very end are text generators used to output text files for downstream compilation.
Each language used to create a particular model can contribute its specific generators to the generation stack.
The (partial) ordering of generation steps in the generation stack is statically defined before the generation starts based on pair-wise priorities between different generators.
The set of generation steps along with partial ordering among them form the generation plan.
Generators are built with a set of expressive DSLs.
For building more complex generators, MPS also exposes a rich API which can be used to implement the transformations.

F.
IDE Extensions MPS also allows the definition of IDE extensions such as new menus or views; laguage engineers use these extensions extensively for building domain specific tooling or to integrate external tools and present their output in a window inside MPS.
The IDE extensions are implemented via regular Java/Swing programs and a couple of MPS-specific extension points.

G.
Other Aspects MPS ships with a few more standard language definition aspects for implementing automation via intentions, data flow analyses, refactorings of models and migration of models when languages evolve.
The standard aspects are covered in our trainings, we refrain here from further details due to space limitations.
The set of language definition aspects can be further extended in a modular manner by language engineers in order to fulfill recurrent language development needs 


b) Choosing the Adequate Notation: Choosing the set of notations (concrete syntax) and making editors look appropriate to the domain experts is highly important for acceptance of the built DSLs by domain experts.
MPS allows language developers to define and combine multiple notations (e.g. textual, tabular, graphical or diagramatic) for the same language.
Making use of this MPS feature at its full potential is very important to increase the readability of domain specific models or lower the learning effort required from new users.
Furthermore, depending on a concrete use-case of the language user, one notation or the other might be preferable (e.g. graphics for overview, textual for rapid development of codelike models).
Thereby we are constantly making aware the trainees about different options they have in order to choose an appropriate notation.



For example, language developers need to be aware of the two means of supporting users in building correct models: constraints, which up-front prevent entering wrong models, and on-the-fly checks, which give users feedback whenever context sensitive constraints are violated.
The first solution might feel strange to the language users when they try to enter a model fragment which is incorrect – MPS will simply not allow to enter the model at all without any explanation and this might feel frustrating to users – many situations perceived as bugs – ”it does not work”.
The on-the-fly checks and errors reporting in IDE allows users to enter the wrong models, but then marks the wrong parts as erroneous with a sensible error message – the user has more support to understand what is wrong and correct the model.



j) Languages Design Idioms: Like any software, there are specific idioms and best practices when developing languages.
Some of the idioms are generic, other idioms are specific to the base technologies behind MPS – e.g. projectional editors.
We make trainees aware continuously about language design idioms.



d) Particularities of MPS: All our trainings are around the MPS technology.
MPS is a highly mature language workbench, but has some strong particularities.
One of the most important particulaties of MPS is that it features a projectional editor.
Thereby, parsing techniques, which are large topics classical in language engineering and which require considerable effort in teaching, are not relevant for MPS.
Instead, we put a lot of effort in teaching the building of editors such that the editing experience of users is improved.
Furthermore, the projectional editor is an enabler for multiple notations and for implementing modular and extensible languages.
Large parts of our trainings are focused on these technical topics which are central to the MPS way of building DSLs.
















[6]	J.-L.
Sierra, “Language-Driven Software Development (Invited talk),” in 3rd Symposium on Languages, Applications and Technologies, ser.
OpenAccess Series in Informatics (OASIcs), Dagstuhl, Germany, 2014.


[10]	D.
S.
Kolovos, R.
F.
Paige, T.
Kelly, and F.
A.
Polack, “Requirements for domain-specific languages,” in Workshop on Domain-Specific Program Development (DSPD), 2006.


[12]	A.
Pescador, A.
Garmendia, E.
Guerra, J.
S.
Cuadrado, and J. de Lara, “Pattern-based development of domain-specific modelling languages,” in Model Driven Engineering Languages and Systems (MODELS), 2015.


[19]	M.
Strembeck and U.
Zdun, “An approach for the systematic development of domain-specific languages,” Software: Practice and Experience, 2009.


