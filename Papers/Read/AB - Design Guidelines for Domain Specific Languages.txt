Nowadays, the need for new languages for various growing domains is strongly increasing.
 
In the following we present general guidelines to be considered for both textual and graphical DSLs with main focus i on the former.

Depending on the concrete language and the domain these guidelines have to be weighted differently as there might be different purposes, complexity, and number of users of the resulting language 
General principles for modeling language design were introduced in [14].
These include simplicity, uniqueness, consistency, and scalability, on which we will rely later 
More practical guidelines for implementing DSLs are given in [10]

[20] explains 12 lessons learned from DSL experiments that can help to improve a DSL

identified the following categories:
* Language Purpose discusses design guidelines for the early activities of the language development process.
* Language Realization introduces guidelines which discuss how to implement the language.
* Language Content contains guidelines which focus on the elements of a language.
* Concrete Syntax concentrates on design guidelines for the readable (external) representation of a language.
* Abstract Syntax concentrates on design guidelines for the internal representation of a language.

Language design is not only influenced by the question of what it needs to describe, but equally important what to do with the language.
Therefore, one of the first activities in language design is to analyze the aim of the language.

“Identify language uses early.” 
The language defined will be used for at least one task.
Most common uses are: documentation of knowledge (only) and code generation.
However, there are a lot more forms of usage: definition or generation of tests, formal verification, automatic analysis of various kinds, configuration of the system at deployment- or run-time, and last but increasingly important, simulation.

An early identification of the language uses have strong influence on the concepts the language will allow to offer 
Who is going to model in the DSL? Who is going to review the models? When? Who is using the models for which purpose?

“Make your language consistent.” [14]
Decide carefully whether to use graphical or textual realization.” 
Nowadays, it is common to use tools supporting the design of graphical DSLs such as the Eclipse Modeling Framework (EMF) or MetaEdit+

As described in [6], there are a number of advantages and disadvantages for both approaches.

Textual representations for example usually have the advantage of faster development and are platform and tool independent whereas graphical models provide a better overview and ease the understanding of models.
Therefore, advantages and disadvantages have to be weighted and matched against end users’ preferences in order to make a substantiated decision for one of the realizations.

Comparisons can be found in [21] or [3].

“Compose existing languages where possible.”
Additionally, when composing languages care must be exercised to avoid confusion: similar constructs with different semantics should be avoided.

“Reuse existing language definitions.” 
If the language cannot be simply composed from some given language parts, e.g., by language embedding as proposed in guideline 5, it is still a good idea to reuse existing language definitions as much as possible.

Looking at the abstract syntax of existing languages, one can identify “language pattern” (quite similar to design pattern), which are good guidelines for language design.

“Reuse existing type systems.” 
an unconventional type system would be hard for users to adopt 
Therefore, a language designer should reuse existing type systems to improve comprehensibility and to avoid errors that are caused by misinterpretations in an implementation.
Furthermore, it is far more economical to use an existing type system, than developing a new one as this is a labor intensive and error-prone task.

One main activity in language development is the task of defining the different elements of the language 

“Reflect only the necessary domain concepts.”
Any language shall capture a certain set of domain artifacts.
These domain artifacts and their essential properties need to be reflected appropriately in the language in a way that the language user is able to express all necessary domain concepts.
However, when designing a language not all domain concepts need to be reflected, but only those that contribute to the tasks the language shall be used for.

“Keep it simple.”
The demand for simplicity has several reasons.
First, introducing a new language in a domain produces work in developing new tools and adapting existing processes.
If the language itself is complex, it is usually harder to understand and thus raises the barrier of introducing the language.
Second, even when such a language is successfully introduced in a domain, unnecessary complexity still minimizes the benefit the language should have yielded.

“Avoid unnecessary generality.” 

“design only what is necessary”.


“Limit the number of language elements.” 
A language which has several hundreds of elements is obviously hard to understand.

“Avoid conceptual redundancy.”
Redundancy is a constant source of problems.


“Avoid inefficient language elements.” 
One main target of domain specific modeling is to raise the level of abstraction.
Therefore, the main artifacts users deal with are the input models and not the generated code.
Concrete syntax has to be chosen well in order to have an understandable, well structured language 

Guideline 14: 
“Adopt existing notations domain experts use.” 
As [20] says, it is generally useful to adopt whatever formal notation the domain experts already have, rather than inventing a new one.

“Use descriptive notations.” 
This applies to keywords with a widely-accepted meaning as well.
Furthermore, keywords should be easily identifiable.
It is helpful to restrict the number of keywords to a few memorizable ones and of course, to have a keyword-sensitive editor.

“Make elements distinguishable.” 
Easily distinguishable representations of language elements are a basic requirement to support understandability.
In graphical DSLs, different model elements should have representations that exhibit enough syntactic differences to be easily distinguishable.
Different colors as the only criteria may be counterproductive, e.g., when printed in black and white.


models are much more often read than written and therefore to be designed from a readers point of view.

“Use syntactic sugar appropriately.”
Generally, if an efficient parser cannot be implemented, the language is probably also hard to understand for human readers.
However, an overuse of the addition of syntactic sugar distracts, because verbosity hinders to see the important content directly.
Furthermore, it should be kept in mind that several forms of syntactic sugar for one concept may hinder communication as different persons might prefer different elements for expressing the same idea.
Nevertheless the introduction of syntactic sugar can also improve a language, 

“Permit comments.” 
Comments on model elements are essential for explaining design decisions made for other developers text boxes and tooltips for graphical languages should be embedded.

“Provide organizational structures for models.” 
Especially for complex systems the separation of models in separate artifacts (files) is inevitable but often not enough as the number of files would lead to an overflowed model directory.
Therefore, it is desirable to allow users to arrange their models in hierarchies 

“Balance compactness and comprehensibility.” 
As stated above, usually a document is written only once but read many times.
Therefore, the comprehensibility of a notation is very important, without too much verbosity.
On the other hand, the compactness of a language is still a worthwhile and important target in order to achieve effectiveness and productivity while writing in the language.


“Use the same style everywhere.” 
DSLs are typically developed for a clearly defined task or viewpoint.
Therefore, it is often necessary to use several languages to specify all aspects of a system.
In order to increase understandability the same look-and-feel should be used for all sublanguages and especially for the elements within a language.
In this way the user can obtain some kind of intuition for a new language due to his knowledge of other ones.

“Identify usage conventions.” 
Preferably not every single aspect should be defined within the language definition itself to keep it simple and comprehensible 
A good example for code conventions for a programming language can be found in [9].

“Align abstract and concrete syntax.” 
Given the concrete syntax, the abstract syntax and especially its structure should follow closely to the concrete syntax to ease automated processing, internal transformations and also presentation (pretty printing) of the model.


“Prefer layout which does not affect translation from concrete to abstract syntax.”
For graphical languages a well-known bad example is the twelve o’clock semantics in Stateflow [7] where the order of the placement of transitions can change the behavior of the Statechart.
To simplify the usage of DSLs, we recommend that the layout of programs doesn’t affect their semantics.

“Enable modularity.” 
One main technique to tackle complexity is modularization [15] which leads to a managerial, flexible, comprehensible, and understandable infrastructure 

“Introduce interfaces.” 
Interfaces in programming languages provide means for a modular development of parts of the system.
This is especially important for complex systems as developers may define interfaces between their parts to be able to exchange one implementation of an interface with another which significantly increases flexibility 

Another common example are ports, e.g., in composite structure diagrams, which explicitly define interaction points and specify services they provide or need, thus declaring a more detailed interface of a part of a system.

a decision whether to reuse existing languages or to implement a new one is one of the most important and critical decisions to be made 

In general, a guideline should not be followed closely, but many of them are proposals as to what a language designer should consider during development.







5.	REFERENCES


[5]	H.
Gronniger, J.
Hartmann, H.
Krahn, S.
Kriebel, and¨
B.
Rumpe.
View-based modeling of function nets.
In Proceedings of the Object-oriented Modelling of Embedded Real-Time Systems (OMER4) Workshop, Paderborn,, October 2007.



[8]	C.
A.
R.
Hoare.
Hints on programming language design.
Technical report, Stanford University, Stanford, CA, USA, 1973.


[10]	S.
Kelly and J.-P.
Tolvanen.
Domain-Specific Modeling: Enabling Full Code Generation.
Wiley, 2008.


[12]	M.
Mernik, J.
Heering, and A.
M.
Sloane.
When and how to develop domain-specific languages.
Technical Report SEN-E0309, Centrum voor Wiskunde en Informatica, Amsterdam, 2005.


[14]	R.
Paige, J.
Ostroff, and P.
Brooke.
Principles for Modeling Language Design.
Technical Report CS-1999-08, York University, December 1999.


[16]	P.
Pfahler and U.
Kastens.
Language Design and Implementation by Selection.
In Proc.
1st ACM-SIGPLAN Workshop on Domain-Specific-Languages, DSL ’97, pages 97–108, Paris, France, January 1997.
Technical Report, University of Illinois at Urbana-Champaign.

[18]	D.
Spinellis.
Notable Design Patterns for Domain Specific Languages.
Journal of Systems and Software, 56(1):91–99, Feb.
2001.

[21]	D.
S.
Wile.
Supporting the DSL Spectrum.
Computing and Information Technology, 4:263–287, 2001.


