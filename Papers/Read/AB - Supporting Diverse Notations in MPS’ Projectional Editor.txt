AB - Supporting Diverse Notations in MPS’ Projectional Editor

To be able to build effective DSLs, these DSLs must not just
use language concepts that are aligned with their respective domain, but
also use notations that correspond closely to established domain notations
– and those are often not purely textual or graphical. The underlying language workbench must support these notations, and combining different
notations in a single editor must be supported as well in order to support
the coherent definitions of systems that use several DSLs. In this paper
we provide an overview over the notations supported by JetBrains MPS.
MPS is a language workbench that uses a projectional editor, which, by
its very nature, can deal with many different notational styles, including
text, prose, math tables and graphics

JetBrains MPS is one of the leading projectional
editors, and this paper describes its capabilities in terms of notational flexibi

Availability of the Code JetBrains MPS is open source software available
from http://jetbrains.com/mps. A

2 Projectional Editing in MPS
What is Projectional Editing? In parser-based editors users type sequences
of characters into a text buffer. The buffer is parsed to check whether the sequence
of characters conforms to a grammar. The parser ultimately builds an abstract
syntax tree (AST), which contains the relevant structure of the program, but omits
syntactic details

s. Subsequent processing (linking, type checks, transformation) is
based on the AST. Modern IDEs (re-)parse the concrete syntax while the user
edits the code, continuously maintaining an up-to-date AST in the background
that reflects the code in the editor’s text buffer. However, even in this case, this
AST is created by a parser-driven transformation from the source text.

A projectional editor does not rely on parsers. As a user edits a program, the
AST is modified directly. Projection rules are used to create a representation of
the AST with which the user interacts, and which reflects the resulting changes.
No parser-based transformation from concrete to abstract syntax is involved.

The projectional approach can be generalized to work with any notation,
including textual. A code-completion menu lets users create instances based on
a text string entered in the editor called the alias. The aliases allowed in any
given location depend on the language definition. Importantly, every next text
string is recognized as it is entered, so there is never any parsing of a sequence
of text strings. In contrast to parser-based editors, where disambiguation is
performed by the parser after a (potentially) complete program has been entered,
in projectional editors disambiguation is performed by the user as he selects
a concept from the code-completion menu

Once a node is created, it is never
ambiguous, irrespective of its syntax : every node points to its defining concept.
Every program node has a unique ID, and references between program elements
are represented as references to the ID. These references are established during
program editing by directly selecting reference targets from the code-completion
menu; the references are persistent. This is in contrast to parser-based editors,
where a reference is expressed as a string in the source text, and a separate name
resolution phase resolves the target AST element after the text has been parsed.

Projectional editing has two advantages. First, it supports flexible composition
of languages because the ambiguities associated with parsers cannot happen
in projectional editors. We do not discuss this aspect in this paper and refer
the reader to [2]. The other advantage of projectional editors is that, since no
parsing is used, the program notation does not have to be parseable and a wide
range of notations can be used.

Traditionally,
projectional editors have also had disadvantages relative to editor usability and
infrastructure integration; those are discussed in [3].

Defining a Simple Editor In order for the reader to better understand the
explanations in Sections 3 and 4, this section briefly introduces the MPS structure
and editor definitions. MPS’ meta model is similar to EMF Ecore [4]. Language
concepts (aka meta classes) declare children (single or lists), references and
primitive properties. Concepts can extend other concepts or implement concept
interfaces; subtype polymorphism is supported. Programs are represented as
instances of concepts, called nodes. Each concept also defines one or more editors.
These are the projection rules that determine the notation of instance nodes in
the program. Editor definitions consist of cells arranged in various layouts. A cell
can be seen as an atomic element of an editor definition.

Textual Notations The first notation supported by MPS has been textual
notations. Notations used by programming languages such as Java, C or HTML
can be represented easily

Mathematical Symbols A plugin [5] supports mathematical notations. The
plugin comes with a set of new layout primitives (cell types) that enable typical
mathematical notations such as fraction bars, big symbols (sum or product),
roots and all kinds of side decorations (as used in abs or floor).

Tables Tables can be used to represent collections of structured data or to
represent two-dimensional concerns. 
Tables come in several flavors. For example, a row-oriented table has a fixed
set of columns and a variable list of rows. Users can add rows, but the columns
are prescribed by the language definition

Prose with Embedded Code One characteristic of projectional editors is
that the language structure strictly determines the structure of the code that
can be written in the editor. While this is useful for code, it does not work for
prose. Hence, an MPS plugin [7] supports ”free text editing” in MPS: all the
usual selection and editing actions known from text editors are supported. The
resulting text is stored as a sequence of IWord nodes

Graphics MPS supports editable graphical notations as shown in Fig. 7. They
can be embedded into any other editor

Custom Cells MPS supports embedding custom cells. This means that the user
can plug in their own subclass of CellProvider and implement specific layout
and paint methods. This way, any notation can be drawn in a low-level way. The
cell provider can be parameterized, and ultimately, it can become a new, reusable
primitive.


4 Other Features of the MPS Editor
As a language workbench, MPS supports the features known from traditional
IDEs for custom languages. These include code completion, quick fixes, syntax
coloring, code folding, goto definition, find references and refactorings. In this
section we describe editor features that are specific to MPS’ projectional editor

Mixed Notations The various notations discussed in the previous section can
all be mixed arbitrarily (with the aforementioned exception of embedding things
into graphical editors). Since all editors use the same projectional architecture
this works seamlessly. In particular, non-textual notations can be used inside
textual notations. Examples include:
– mathematical symbols embedded in textual programs
– tables that contain text or math symbols
– tables embedded in textual programs
– mathematical symbols embedded in prose
– lines, progress bar other other shapes embedded arbitrarily

Multiple Editors A single concept can define several editors, and a given
program can be edited using any of them. Each of the multiple editors has a tag,
and by setting tags in an editor window (either by the user or programmatically),
the editors corresponding to these tags can be selected. For example, state
machines can be edited in a textual version 


Partial Syntax Editors can also be partial in the sense that they do not
project all contents stored in the AST. Of course the non-projected aspects of the
program cannot be edited with this particular editor.

Conditional editors essentially support aspect orientation
for editor cells. A conditional editor defines a decoration for existing editors as
well as a pointcut that determines to which existing editor cells the decoration
is applied

Annotations Annotations are similar to conditional editors in that they can
render additional syntax around (or next to) existing syntax without the original
syntax definition being aware of this.

Read-Only Contents Especially in DSLs for non-programmers it is often
useful to be able to project rigid, predefined, non-deletable skeletons of the to-bewritten program in order to guide the user. F


