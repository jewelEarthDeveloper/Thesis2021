AB - Rete A Fast Algorithm for the Many Pattern/Many Object Pattern Match Problem

In many pattern/many object pattern matching, a collection of patterns is
compared to a collection of objects, and all the matches are determined. That
is, the pattern matcher finds every object that matches each pattern. 

For instance, it is a basic component of production system interpreters.
The interpreters use it to determine ~vhich productions have satisfied condition
parts. Unfortunately, it can be slow when large numbers of patterns or objects
are involved. Some systems have been observed to spend more than ninetenths of their total run time performing this kind of pattern matching [5]. 

A production system program consists of an unordered collection of If-Then
statements called productions. The data operated on by the productions is held
in a global data base called working memory. By convention, the If part of a
production is called its LHS (left-hand side), and its Then part is called its RHS
(right-hand side). The interpreter executes a production system by performing
the following operations. 

(1) Match. Evaluate the LHSs of the productions to determine which are
satisfied given the current contents of working memory.
(2) Conflict resolution. Select one production with a satisfied LHS; if no
productions have satisfied LHSs, halt the interpreter.
(3) Act. Perform the actions in the RHS of the selected production.
(4) Goto 1.
The algorithm that will be presented here, the Rete Match Algorithm, can be
described as an indexing scheme that does not require the interpretive step.
The indexing function is represented as a network of simple feature recognizers. This representation is related to the graph representations for so-called
structured patterns.

The Rete algorithm was first
described in 1974 [3]. A 1977 paper [4] described some rather complex
interpreters for the networks of feature recognizers, including parallel interpreters and interpreters which delayed evaluation of patterns as long as
possible. (Delaying evaluation is useful because it makes it less likely that
patterns will be evaluated unnecessarily.) A 1979 paper [5] discussed simple but
very fast interpreters for the networks. This article is based in large part on the
1979 paper. 


s. The
algorithm can efficiently process large sets because it does not iterate over the
sets. 

The iteration can be avoided by storing, with each
pattern, a list of the elements that it matches. The lists are updated when
working memory changes. When an element enters working memory, the
interpreter finds all the patterns that match it and adds it to their lists. When an 
element leaves working memory, the interpreter again finds all the patterns
that match it and deletes it from their lists

The Rete algorithm avoids iterating over the set of productions by using a
tree-structured sorting network or index for the productions.


The Rete Match Algorithm is a method for comparing a set of patterns to a set
of objects in order to determine all the possible matches. It was described in
detail in this article because enough evidence has been accumulated since its
development in 1974 to make it clear that it is an efficient algorithm which has
many possible applications


The algorithm is efficient even when it processes large sets of patterns and
objects, because it does not iterate over the sets. In this algorithm, the patterns
are compiled into a program to perform the match process. The program does
not have to iterate over the patterns because it contains a tree-structured
sorting network or index for the patterns. It does not have to iterate over the
data because it maintains state information: the program computes the matches
and partial matches for each object when it enters the data memory, and it
stores the information as long as the object remains in the memory. 

If there is anything
unusual about the pattern matching of production systems, it is only that the
pattern matching takes place on an unusually large scale. Production systems
contain rather ordinary patterns and data objects, but they contain large
numbers of them, and invocations of the pattern matcher occur very frequently
during execution. If programs of other kinds begin to use pattern matching
more heavily, they could have the same efficiency problems as production
systems, and it could be necessary to use methods like the Rete Match
Algorithm in their interpreters as well.

Certainly the algorithm should not be
used for all match problems; its use is indicated only if the following three
conditions are satisfied.
-The patterns must be compilable. It must be possible to examine them and
determine a list of features like the lists in Section 2.2.1.
-The objects must be constant. They cannot contain variables or other
non-constants as patterns can.
- The set of objects must change relatively slowly. Since the algorithm maintains
state between cycles, it is inefficient in situations where most of the data changes
on each cycle. 



