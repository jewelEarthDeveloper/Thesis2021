AB - Language Modularization and Composition with Projectional Language Workbenches illustrated with MPS

With the advent of projectional language workbenches a new class of language becomes possible that can combine the best of both approaches: modular languages.

Modular Languages use a relatively small general-purpose core and can be extended with more (domain specific) concepts as needed.
Projectional language workbenches support this approach by alleviating the problems of language composition for parser-based languages by not using grammars and parsers at all 
However, traditionally, modular languages have been hard to achieve because of the inherent problems in grammar composition and modular IDE construction [1, 20].
Projectional language workbenches [2] do away with these problems and make modular languages and IDEs easily possible. 

Modular languages are flexible because users can use only those language concepts in a program they really need.
They are extendable because a module can be custom built.
Modular languages are productive because the scope of applicability of the module can vary from general-purpose to domain-specific.
They are also simple to use because users don't have to learn (or expressly ignore parts of) huge monolithic languages, they only have to deal with those language modules they really use.
Modular languages are convenient because, if the right tools are used, they come with their own IDE just like traditional languages.


The term Language Workbench has been coined by Martin Fowler in 2005 [2].
In his article he defines it as a tool with the following characteristics:
1. Users can freely define languages which are fully integrated with each other.
2. The primary source of information is a persistent abstract representation.
3. A DSL is defined in three main parts: schema, editor(s), and generator(s).
4. Language users manipulate a DSL through a projectional editor.
5. A language workbench can persist incomplete or contradictory information.

Note how points 2, 3 and 4 imply projectional editing.
In the meantime, Martin Fowler, and the community as a whole uses the term language workbench also for tools that use (modern) parsing techniques. 

Projectional editing is well-known from graphical modeling tools (UML, ER, State Charts).
The model is stored independent of its concrete syntax, only the model structure is persisted, often using XML or a database.
For editing purposes this abstract syntax is projected using graphical shapes.
Users use mouse gestures and keyboard actions tailored to graphical editing to modify the abstract model structure directly.
While the concrete syntax of the model does not have to be stored because it is specified as part of language definition and hence known by the projection engine, graphical modeling tools usually also store information about the visual layout 
Projectional editing can also be used for textual syntax.
However, since the projection looks like text, users expect interaction patterns and gestures known from "real text" to work.
For a projectional editor to be useful, it has to "simulate" interaction patterns known from real text.

The following is a list of benefits of projectional editing:
 No grammar or parser is required.
Editing directly changes the underlying structure.
Projectional editors can handle unparseable code.
Language composition is easily possible, because languages composition cannot result in ambiguous grammars [1, 19, 20].
 Notations are more flexible than ASCII/ANSI/Unicode.
Graphical, semi-graphical and textual notations can be mixed and combined.
For example, a graphical tool for editing state machines can embed a textual expression language for editing the guard conditions on transitions.
 Because projectional languages by definition need an IDE for editing (it has to do the projection!), language definition and extension always implies IDE definition and extension.
The IDE will provide code completion, error checking and syntax highlighting for all languages, even when they are combined.
 Because the model is stored independent of its concrete notation, it is possible to represent the same model in different ways simply by providing several projections.
Different viewpoints [11] of the overall program can be stored in one model, but editing can still be viewpoint specific.
It is also possible to store out-ofband data, i.e. annotations on the core model/program.
Examples of this include documentation, pointers to requirements (traceability) [12] or feature dependencies in the context of product lines [13].


As a side effect, language workbenches deliver on the promise of removing the difference between what is traditionally called programming and what is traditionally called modeling.
This distinction is arbitrary anyway: as software developers we want to express different concerns of software systems with abstractions and notations suitable to that particular concern (graphical, textual, symbolic), formally enough for automatic processing or translation, and with good IDE support.
Projectional language workbenches deliver on this goal.

JetBrains MPS
JetBrains’ Meta Programming System [9] is an open source projectional language workbench, so all the statements made earlier apply to MPS.
It comes with Java and XML as extendible default languages.
Defining a language includes (a) defining the language concepts (abstract syntax), (b) defining the editor for the concepts and (c)
defining a generator (compiler).
For a language whose programs should be processed with a text-oriented tools (such as existing compilers or interpreters) the generator outputs text.
For higher-level languages, the generator transforms the programs into programs expressed in lower level languages.
In this case, the generators are not text generators, they transform between abstract syntax trees (this process is explained in more detail below).
Editing the tree as opposed to “real text” needs some getting used to.
Without specific customization, every program element has to be selected from a drop-down list to be "instantiated".
However, MPS provides editor customizations to enable editing that resembles modern IDEs that use automatically expanding code templates.
This makes editing quite convenient and productive in all but the most exceptional cases. 

Concrete Syntax Definition.
Instead of defining a grammar and deriving the abstract syntax, in MPS the editor definition is based on the language structure as shown in the left part of figure 2.
Figure 2: Syntax/Editor definition, the condition for the init expression is on the right The editor for the LocalVariableDeclaration consists of an indent-collection ([- …
-]), a kind of collection which results in a text-like presentation (horizontal, with line breaks).
It contains the representation of the type (%type%), the name ({name}) and the init expression (%init%) if it has one (?).
The condition (right half of figure 2) makes sure the initialization expression, as well as the equals sign, is only shown if an initialization expression is provided.
Finally, the horizontal collection contains a semicolon - a simple constant.
It is assumed that editors for Type and Expression are already defined in the base language.
Those editors are simply used (i.e. embedded) here as we refer to %type% and %init%.

Type Systems.
Type systems [27] defines and validate variable types.
Every nontrivial language has a type system and MPS comes with a DSL to define type systems for languages.
Figure 3: Definition of the type system rules The type system rules in Figure 3 define that the type of the type property and the type of the overall statement have to correspond.
In other words, the type of the whole statement is the type given in its type property.
The second rule (within the if block) says that if an init expression is defined, the type of init must be a subtype of the type of the defined variable.
Type equations not shown here establish the types of the Type and Expression concepts.

Editor Tuning.
At this point the definition of the language and the basic editor, as well as the type system are finished.
However, if you'd try to use the new LocalVariableDeclaration statement, you'd have to literally press control space in the editor, select the concept LocalVariableDeclaration and use tab or the mouse to fill in  the various properties (type, name, init).
This is unacceptable.
Additional steps have to be taken to allow users to simply type int i = 2*3; the way they're used to.

We explain all of this to illustrate what's involved in defining languages in a projectional editing environment.
As the examples below will show, projectional editing has a number of intriguing advantages, but there is also a price to pay: this price is the additional effort that goes into defining a nicely usable editor.
The tools (MPS in this example) come with the necessary facilities and makes defining these editor convenience functions relatively easy.

in general, domain-specific languages, or domain-specific extensions of general purpose languages cannot be directly executed.
The model has to be translated into a language for which some kind of execution infrastructure (a compiler or interpreter) exists.
In an environment where models and programs are treated the same in that they are both stored as an abstract syntax tree and projected for editing, there are two different scenarios for code generation:
 domain-specific languages or language extensions typically need to be mapped to general purpose languages such as Java or C.
 Since the general purpose languages themselves are represented via an AST and projection, the programs cannot be feed directly to the compiler, a text representation has to be generated from them.
The second case is rather straight forward.
It is basically pretty printing (aka unparsing), since the syntax of the language (abstract + concrete) directly resembles the text to be generated.
The first case is more interesting.
Since both, the DSL (or extension) and the target language are represented as AST + projection, such a code generator is in fact a model transformation in the sense that the DSL AST is transformed into the target language AST.
There is no actual text generation.

Here is the point of this example: Both reduction rules use the concrete syntax of the target language in the templates, so it looks as if this is a text-generationtemplate, when in fact it is a model transformation.
To make this possible, the existing projections for the target language are used to project the resulting model in the syntax of the target language.
This is visually similar to text generation templates that also use the concrete textual syntax of the target language.
But the projectional approach goes further: when writing the to-be-generated code, the IDE provides syntax coloring, code completion and error checking for the template code.
This is extremely hard to do for parsed languages, because the parser of the target language has to be embedded into the template language, and IDE services (code completion, syntax coloring, static checks) would have to be merged as well.
We have not yet seen such as tool in parser-based languages, although the work of the Spoofax [23] team is very promising.


Different Notations.
The ability to have several different notations for the same language concepts is not technically related to language extension.
But it is nonetheless very useful.
For example, in figure 15, a state machine can be represented as a table inline in the textual C program.
The two notations can be switched back and forth.

While we are aware that parsing technology also moves forward, and language composition will become much more practical in these environments as well, we feel that projectional editors are a very promising way for the future, especially since they can integrate textual, symbolic and graphical notations.
Traditionally, the biggest complaint about projectional (or structural) editing has been that the editing experience is not very convenient.
As MPS demonstrates, these reservations are not valid (anymore).


