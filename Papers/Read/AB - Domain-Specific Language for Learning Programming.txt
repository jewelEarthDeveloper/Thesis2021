Domain-Specific Language for Learning Programming 
MPS is based on technology of projectional editor.
A projectional editor directly manipulates with abstract syntax tree (AST).
An MPS language is called projectional language.
Each projectional language has three main parts: language structure, a projectional editor, and a generator.
Language structure defines the structure of AST, the editor defines language syntax and how can users edit the AST, and the generator defines how is the created code of DSL transformed to some textual output or another projectional language 
Traditional languages environment uses a lexer and a parser to convert input source code in plain text form to AST.
The lexer gets text as a sequence of characters and produces sequence of tokens – words used in the language such as keywords and identifiers.
The parser then reads the sequence of tokens and creates AST. 

A projectional editor does not work with text, but it creates and modifies AST.
AST is projected into projectional editor in the way that it looks like textual source code.
A user can write only things that are valid in AST.
Projectional editor provides intelligent code completion out of the box and MPS contains various mechanisms to allow edit the language like in common text editor.

There are three types of modules:
language, solution, and DevKit.
The language module contains language definition.
The solution module can be either a run-time module or a sandbox module.
Run-time solutions are sometimes called libraries and contain arbitrary code written in some MPS language or stubs that allow using some Java classes or libraries.
Sandbox solutions contain user programs.
DevKit modules allow packing more languages and solutions together so they are easier to use.
Modules may depend on other modules and use their code.
A language can extend other language 
Modules consists of models.
Language models are called aspects.
There is a set of aspects in MPS and every aspect has different role in language definition. 

The main parts are: Structure aspect, Editor aspect, and Generator or TextGen aspect.
At first, a Concept must be defined in Structure aspect.
On the right side of Figure 3.2, there is a definition of the concept.
AST of a program is built from nodes and each node is an instance of some concept Projectional languages code is usually transformed to either text (e.g. XML, Java) or to some other projectional language.
Projectional language transformation to other projectional language is done by Generator aspect and it offers more options than transformation into textual language, which is done by TextGen aspect 
For the purpose of transformation into a projectional language, MPS provides BaseLanguage, which is a clone of Java, and it is finally generated into textual Java code 

Structure aspect defines which nodes can be part of AST and how they can be structured.
Structure aspect has 5 concepts:
z Concept 
z Interface concept 
z Enum Data Type 
z Constrained Data Type 
z Primitive Data Type Declaration Concepts define base build blocks of the language.
Instances of concepts are nodes in AST.

A concept can have properties, children, and references.
Properties contain simple literals, children define concepts of child nodes in AST, and references point to some existing nodes in language AST.
Concept has an alias and short description.
Alias is used to refer to the concept in an editor.
Both alias and short description are used as labels in a code completion menu.
Concepts have inheritance hierarchy.
A concept can extend another single concept and can implement multiple interface concepts.
A concept can be marked as abstract; abstract concepts cannot be instantiated.
There is a special sort of concepts called root concepts.
Only instances of root concepts can be created as a new node in the Logical View.

Interface concepts represent independent traits.
They define some functionality that can be reused in more concepts and one concept can implement multiple interface concepts.
Same as concepts, they can have properties, children, and references.

The other three concepts Enum Data Type, Primitive Data Type Declaration, and Constrained Data Type allow defining data type for literals as enumeration type, string-based type constrained with some regular expression, or as a new primitive type.
Defined types can be used as types of properties.

Other editor nodes allow defining actions that can manipulate with AST or editor when some events are triggered.
The events are for example node deletion, pasting node from clipboard, or pressing key.
It is possible to define more editors for one concept and then switch between these editors in IDE.

In Behavior aspect there can be defined a Behavior node for each Concept or Interface Concept.
Behaviour node contains node constructor, and instance and static methods.
Static methods can be called through Concept.
Instance methods can be called on nodes that are created as instance of Concepts.
Methods can be marked as virtual and then be overridden.
Methods in Behavior node of abstract Concept can be abstract 
Constraints aspect can introduce some constraints on concept child nodes, properties, and references.
In structure aspect there is defined type of each child or reference node.
Constraint aspect allows creating some more complex checks based on current context.

Actions aspect helps to improve editor usability.
It allows defining node transformations.
The main nodes are: Node Factories, Transform Menu Actions, and Node Substitution Actions.
Node Factories defines how a new instance of node is created based on enclosing node or when it is created to replace some other node. 

Node Substitute Action allows substituting a node or wrapping a node with some other node.
When MPS creates items for code completion menu, it searches also for these Node Substitute Actions. 

Typesystem aspect allows to compute types and to check them.
The main concepts are: Inference Rule that allows to define types for concepts, Subtyping Rule to define a type hierarchy, and Non-Typesystem Rule to define a custom validation for any node.

Dataflow aspect defines rules for a static analysis.
For each concept, a language execution flow can be defined using jumps, conditional jumps, variable reading and writing, and evaluation of dataflow of child nodes. 


Intentions aspect is concept used in IntelliJ IDEA platform.
It is contextual menu invoked by specific keyboard shortcut with some actions connected to the current cursor position in the code.
In MPS, it allows to create custom AST node transformations 
Generator aspect allows transforming code from defined language to some other projectional language, typically into BaseLanguage – a projectional clone of Java.
Generation is done using templates and mapping configuration. 


TextGen aspect serves to transform language AST into a text.
If the output text is source code in some language, it can be then compiled or interpreted with standard tools 
Source code of DSLs designed in MPS can be build and distributed as a language plugin.
Languages can be built as a plugin for MPS, a plugin for IntelliJ IDEA, or a Standalone IDE.
The plugin for MPS is the simplest solution how to use language.
Languages can be imported into other MPS projects and they can be used there.
A language that is packed as the plugin for IntelliJ IDEA can be used in IntelliJ IDEA projects.
It requires installing MPS plugin for IntelliJ IDEA.
The last option is to create a standalone MPS distribution customized to edit particular languages.

Tools can provide any functionality GUI component implemented in Java using Swing.
These custom Tools can be packed and distributed together with MPS languages in a custom MPS distribution. 

The first advantage of MPS is that projectional languages have defined editors with rigid syntax, which may guide the novice programmers.
An intelligent code completion can be sophisticated and larger parts of code can be inserted automatically, so syntax can be more explanatory without the need of writing more.
Users do not need to take care about inserting special characters such as parenthesis or semicolons.
Editor has also pre-defined layout, which takes care about spacing and indentation.

Syntax highlighting can reflect also relations between nodes, not only their syntax.
Additional text can be added to the editor and it can vary as user is changing the code, e.g. when some node is missing, a textual hint can be added there to help user to correct it, once the code is correct, the hint disappears.
Projectional code does not have to be parsed, so language syntax can have much more options and languages can be freely combined together.
There is also support for visual elements such as tables or diagrams.
The fact that projectional editor manipulates directly with AST allows to implement some editor features that are common in mature IDEs with much less effort.
MPS provides an intelligent code completion out of the box.
Thanks to typesystem and dataflow aspects, it is easier to implement some checks, so some errors can be reported immediately when they are made and it is harder to write invalid code.

3.6 Limitations 
Most of the limitations come from the fact that MPS language code is not plain text, but each single MPS model, which can contain more root nodes, is stored in a single XML document.
Projectional language code can be read and write only in MPS, in IntelliJ IDEA with MPS plugin, or in custom MPS IDE.
The language must be also packed as a language plugin and imported into the IDE.
Code from MPS editor can be copied as text, but when it is necessary to insert plain text code back into MPS editor, it requires extra effort to implement a parser for the language.
It is also impossible to do version control without the MPS VCS plugin, which understands AST XML representation.
A programmer cannot do manual merge and even small changes that does not influence code appearance in editor, can broke some references in AST and make the code invalid.
Therefore, a change in implementation can break existing code.
In order to allow language evolution MPS provides Migration aspect to transform code between different versions of language.
MPS developers plan to provide MPS as web application in futures versions, but it is not certain that MPS will develop in this direction and it could take years.
This prevents us from providing the language online with a customized and simplified user interface.

4.4.1 Roots 
Every code must be written in some kind of document.
An instance of root concept represents a single file in Logical View in MPS.

The main parts of MPS are the projectional editor and the build system.

When users write some code in Eddie, it must be somehow executed.
There are two possible approaches how to execute created code.
First option is to use Generator aspect.
Generator defines how code in Eddie is transformed into BaseLanguage and the result can be executed as Java.
The second option is to create an interpreter that would interpret Eddie 
MPS provides Open API [11] that allows accessing AST of models, 

The limitations of generator approach are that it runs in different JVM, so it can communicate with Eddie Studio only over the network.
It has also different Java classpath, so it is not possible to create parameters for network communication at runtime and pass them in a file in shared classpath.
As a result of this, it would be difficult to run more instances of Eddie Panel in the same time, e.g. in Eddie Studio 
and in MPS, because a port and a service name must be hardcoded in common libraries or stored in a configuration file in user home directory