 MPS is an open-source language workbench that focuses on Domain-specific languages. The project started in 2003 as an experiment to try innovative concepts, such as projectional editor and code generation, on the Java platform. It has gradually evolved into a regular tool that is ready for use in the industry. The open-source license permits users to use MPS in commercial as well as open-source and academic projects without fees or any liabilities to JetBrains. JetBrains offers consultancy, training and commercial support to the customers to fund further development of the tool.

 https://www.youtube.com/watch?v=7jck5QBLQeQ

 create an html of the rules so that they can be inspected by our security person and put into the isms!

 Language workbenches are universal, domain-agnostic meta-modling tools
 - create single-purpsoe modeling tools- assist in designing all aspects of a languageEnable both modelling and programming languages

 Charateristics of Language Workbenches:
 IDE Support
  - efficient keyboard entry
  - refactoring
  - type system checks
  - code analysis
  - Tests
 Code generation
 Integrates with General Purpose Language (GPL) codease and tooling
 integrates with CI and VCS

 others - Xtext, Intentional, spoofax

 capabilities
  - create new languages
  - extend existing languages
  - Combine multiple languages in the code

 Applicable domains
	automate repetitive domains
	 - product lines
	 - bad framworks
	 - models for multiple domains

	get semantically closer to the domain
	 - capture structure/behaviour of domain formally
	 - communicate
	 - easier analysis
	 - prove correctness
	 - customized ide to support dsl



MPS is a universal language workbench.


Projects in MPS consist of modules. Modules are independent reusable collections of code. There are four types of modules in MPS:

Solution - represents a piece of user code and is equivalent to how code is structured in traditional IDE's.
Language - represents language definition.
Generator - represents a transformation of code that is written one language into code written in another one. Each generator belongs to exactly one Language module. A Language module contains exactly one Generator module.
DevKit - groups modules (Solutions and Languages) for easy reference, does not add any new code or functionality. A module can be part of multiple DevKits.

Internally, modules are structured into models. Models are a language-agnostic equivalent of Java's packages, Ruby's modules or JavaScript folders. Models hold root nodes, which you may think of as an equivalent of files. Root nodes "are" the code. Technically, they represent the roots of trees (aka Abstract Syntax Tree) and hold other nodes organized into a tree-like hierarchy.

There are three main benefits of using Language Engineering:
Productivity
Quality
Leveraging expertise

Main gains in productivity come from removing repetition from code and from raising the abstraction level closer to the problem domain. Higher levels of abstraction support programmer's focus and reduce the abstraction gap between the domain and the language. This also applies to the maintenance phase. Reading and understanding code can be greatly improved by raising the level of abstraction.

comes at a price of higher initial costs - the languages must first be designed and implemented.

Quality
Code written using domain-specific languages tends to contain fewer defects, mainly due to these reasons:

The code is shorter than when written using a GPL.
The code is easier to analyze by tools and reviewed by humans.
The language can forbid dangerous or suspicious code constructs, e.g. pointer manipulation or null values
Error messages that the IDE shows to the user can be also domain-specific, e.g. "Symbol is not available on a phone keyboard".
The generator generates code with consistent quality - new features (aka business rules, menus, etc.)  have the same quality as the old ones, since the generator used to generate runnable code for them is the same.

Language engineering separates the concerns of the problem domain and the implementation domain.

Problem domain - is covered by the user models using the DSLs. Domain experts understand this domain and so they benefit from being able to read or write code that targets the problem domain. The domain experts' expertise is encoded in the user models.

Implementation domain - is covered by the generator and the generator run-time frameworks.

The separation of the two concerns enables business to evolve each domain at its own pace and react to challenges in either of them.

Domain experts that join the team can understand the business rules covered by the models from reading the user models, since the problem domain is not cluttered with alien implementation logic.

Switching the implementation technology should ideally only mean to define a new generator. The user models, which hold the essential business logic, remain valid and usable even when the implementation technology changes dramatically.

Compilers, interpreters as well as IDEs need to manipulate code that the user provides. Code is typically provided in text files and the extension of the file indicates the language used by that file. Computer programs, in order to represent the code in memory, need to read the files and process them with a special tool, called parser. Parser uses the known grammar of the language to distinguish individual tokens in the text file and to assign meaning to them. As the parser reads the file it gradually builds a data structure that is known as Abstract Syntax Tree. The structure represents the code fully and unambiguously. Abstract Syntax Trees (AST for short) serve the IDE to provide assistance to the user as well as they serve the compiler to perform transformations that gradually convert the tree into runnable binary code.

languages are sets of concepts

programs/models are represented in memory as a tree (graph) data structure known as abstract syntax tree it consists of nodes in parent child relationships with possible references and these nodes are of certain concepts and concepts come from a certain language that you use in your programmer


People who participate on a project that involves designing languages and tooling for them frequently find themselves in one or more of the following roles:
Domain expert - a professional with a specific domain of expertise
DSL user - a domain-aware person using the designed languages to implement the domain-specific logic
Language designer - designs the individual aspects of a languag
Ergonomist - optimizes the notations and the visual side
Generator author - implements the transformation rules
Generator framework author - a professional programmer who creates frameworks and libraries
Tooling designer - a professional programer that writes extensions to the IDE

The chosen notation directly influences the success of a language.
notation should be simple and concise and provide sensible defaults. If a preferred notation exists already in the domain, it is advisable to reuse or adapt it in the new language.

the support that the IDE provides (code-completion, scoping, intentions, refactorings, navigation, error detection, etc.) adds to the usability of the notation itself.

Tools like MPS that build on the principles of projectional (sometimes called structured) editing can offer a wider range of notations.


Symbols - notations that combine text with non-textual symbols. Math, for example, has been using symbols for centuries and there are good reasons to support these symbols in languages used in math-heavy computations.

State machines - some domainsuse state machines to model systems that react to external events and change their internal state following some pre-defined set of rules. To express the transitions in individual states after arrival of certain events a table can be used with good success.

Diagrams - numerous problems are best solved in graphics - electrical circuits, organizational charts, workflows, etc.

Forms - rich text editors are also frequently utilized for encoding rules of various sorts.

 notations can be optimized towards easy readability or towards writability

 Since MPS enables language designers to provide multiple notations for a language, which the users can easily switch when editing code, the trade off between learnability and effectivity as well as between readability and writability does not need to be made in MPS languages.


 The generator will be used to generate runnable code from the DSL code. There can possibly be several generators for the same DSL, each generating different implementation code.

 A generator must not influence the design of the language

 A generator consists of stable and variable parts. Stable parts is the code that is always generated unchanged, no matter how the user implements the logic in the DSL. Large portions of the stable parts are frequently extracted away from the generator and implemented as a library that bundles with the generated code at run-time.



 When you write code in MPS, you do not manipulate code on character level. Instead you obey the rules of structured editing

3 benefits of projectional editors
1) richness of the notations you can use in your languages
2) change notations on the fly, so you can choose the notation that best suits the problem at hand
3) combine languages easily

The languages used for defining languages are also defined in MPS, so MPS languages are fully bootstrapped. In other words, defining languages is also a modelling activity, modelling with DSLs in the domain of language engineering.


Structure - defines the abstract syntax that consists of concepts
Editor - defines the visualizations of concepts and the way users interact with code
Actions - defines node factories and copy-paste handlers
Constraints - further constrains the structure - what values properties can have, where references can point and what children or parents nodes can have
Behavior - defines functionality associated with concepts and nodes
Typesystem - for languages with values and expressions defines typing rules that help detect typing errors in code
Intentions - enable context-aware suggestions for automated code manipulation
DataFlow - defines flow of data and control through code so that analyzers can be built to detect flow-related issues, such as unreachable code or potential null-pointer exception
Generator - defines semantics of the code, i.e. transformation rules for translating the code into a language with semantics, like Java, C, XML and others

and there are many more that can be specified on demand

structure - is most important, without this the language cannot do anything.
contains the concepts out of which the programmers build their programs

object orientated


The editor aspect lets us define projections of the concept on the screen that enable the user to interact with the code. During the user interacting with the code properties, children and references of the concepts get set or changed. All properties, child nodes or collection of children as well as references are represented in the editor by editor cells.

These cells are bound to the properties, nodes or references in the AST, display their current value and propagate any user changes to the corresponding properties, nodes and references in the AST.

An editor definition is effectively a tree of editor cells - it can be a single cell or multiple cells contained in a single parent cell.

----
(from https://www.youtube.com/watch?v=uvCc0DFxG1s)
the editor ultimately is a big swing panel
----

 a generator converts an input model into an output model, which can then be processed by another generator. So generators form a pipeline that takes user code on one end and gradually transforms it into a final model that is then converted to text using TextGen definitions of the concepts in the final model.
 
 These macros are attached to elements of the template and ensure that during generation the annotated elements of the template get replaced with values specified by the macro.
 
 
 With MPS you not only create languages but also tooling that assists the developers when they use the languages. This includes:
*new menus, contextual menus and sub-menus
new entries in the menus
*intentions to suggest the users automatic changes and improvements to the code
*quick-fixes to automatically fix discovered errors in code
*language migrations to automatically upgrade user models to the most recent version of a language
*refactorings to automatically modify the structure of the code
*tool windows to show additional information to the user in a separate panel
*preferences to provide additional configuration options

In MPS language designers not only define the abstract and concrete syntax of languages, the semantics, type-system, constraints and other essential traits of languages, but also the IDE support for the languages - refactorings, configuration screens, menus, tool windows and Intentions.

structure - the definition of concepts that specify the shape of the model (abstract syntax tree) and relationships between nodes
editor - the definition of visual representation of the code and the way users interact with the code
generator - the definition of semantics, i.e. the meaning of the code through rules that translate the code into another language


Generator macros allow replacing properties, child nodes and references in templates with properties, nodes and references coming from the input model.

Scopes in MPS define the set of possible targets for references. By default, a reference can point to any target node that exists in the current model, as well as in all the models imported into the current model. The Transition concept in our project defines two references - trigger and target.


